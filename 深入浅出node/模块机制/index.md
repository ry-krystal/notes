#### 模块机制

1. 在 node 中引入模块，需要经历如下 3 个步骤：

- 路径分析
- 文件定位
- 编译执行

在 Node 中，模块分为两类：一类是 Node 提供的模块，也叫核心模块；另一类是用户编写的模块，叫作文件模块。

- 核心模块部分在 node 源代码的编译过程中，编译进了二进制执行文件。在 node 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。

2. 优先从缓存加载

- 与前端浏览器会缓存静态脚本文件以提高性能一样，node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 node 缓存的是编译和执行之后的对象。
- 无论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

       2.1 路径分析和文件定位

       因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异。

       1. 模块标识符分析
       - 核心模块、如http、fs、path等。
       - .或..开始的相对路径文件模块。
       - 以/开始的绝对路径文件模块。
       - 非路径形式的文件模块，如自定义的connect模块。)

       - 核心模块：优先级仅次于缓存加载
       - 路径形式的文件模块：以.或者..和/开始的标识符，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。其加载速度慢于核心模块。
       - 自定义模块：查找时最费时的，也是所有方式中最慢的一种。

      2.2 文件定位

       从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析，目录和包的处理。

       - 文件扩展名分析

       require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJs模块规范也允许在标识符中不包含文件扩展名，这种情况下，node会按.js、.json和.node的次序补足扩展名，依次尝试。

       在尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷。

       - 目录分析和包
      在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。
      在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json，通过JSON.parse()解析包描述对应，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析步骤。

       而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认

node 标识符分类如下：

!['node标识符分析'](node标识符分类.drawio.svg "node标识符分类")

node 模块分类如下：

!['node模块分类'](node模块.drawio.svg "node模块分类")

node 文件定位如下：

!['文件定位'](文件定位.drawio.svg "node文件定位")
