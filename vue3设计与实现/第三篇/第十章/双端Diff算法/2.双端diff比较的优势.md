#### 双端比较的优势

理解了双端diff比较原理后，我们来看看与简单diff算法相比，双端diff算法具有怎样的优势。拿原来的例子来说：
![新旧两组子节点](../../../images/新旧两组子节点.drawio.svg '新旧两组子节点')

当使用简单diff算法对比此例进行更新时，会发生两次DOM移动操作，如图所示：
![两次DOM移动](../../../images/把节点p-2对应的真实DOM移动到节点p-1对应的真实DOM后面.drawio.svg '两次DOM移动')

如果使用双端diff算法对此例进行更新，会有怎样的表现呢？接下来，我们就以双端比较的思路来完成此例的更新，看一看双端diff能否减少DOM移动操作次数。

![双端diff比较新旧两组子节点与真实DOM节点的状态](../../../images/双端diff比较新旧两组子节点与真实DOM节点的状态.drawio.svg '双端diff比较新旧两组子节点与真实DOM节点的状态')

可以看到，在第四步的比较中，我们找到了可复用的节点p-3。该节点原本处于所有子节点的尾部，但在新的一组子节点中它处于头部。因此只需要让节点p-3对应的真实DOM变成新的头部节点即可。在这一步移动操作之后，新旧两组子节点以及真实DOM节点的状态如图所示：

![双端diff节点p-3移动](../../../images/双端diff节点p-3移动.drawio.svg '双端diff节点p-3移动')

在这一轮比较过后，真实DOM节点的顺序已经与新的一组子节点顺序一致了。换句话说，我们完成了更新，不过算法仍然会继续执行。开始下一轮的比较。
比较之后，如图所示：

![双端diff比较p-1节点之后的真实DOM状态](../../../images/双端diff比较p-1节点.drawio.svg '双端diff比较p-1节点之后的真实DOM状态')

此时，双端diff算法仍然没有停止，开始新一轮的比较，比较之后，如下图：

![双端diff比较p-2节点之后的真实DOM状态](../../../images/双端diff比较p-2节点之后的真实DOM状态.drawio.svg '双端diff比较p-2节点之后的真实DOM状态')

到这一步后，索引newStartIdx和oldStartIdx的值比索引newEndIdx和oldEndIdx的值大，于是更新结束。可以看到，同样的例子，采用简单diff算法需要两次DOM移动操作才能完成更新，而使用diff算法值需要一次DOM移动操作即可完成更新。