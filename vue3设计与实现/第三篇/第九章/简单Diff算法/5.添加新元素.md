#### 添加新元素

```js
  function patchChildren(n1, n2, container) {
    if (typeof n2.children === 'string') {
      // ...
    } else if (Array.isArray(n2.children)) {
      const oldChildren = n1.children
      const newChildren = n2.children

      // 用来存储寻找过程中遇到的最大索引值
      let lastIndex = 0
      for (let i = 0, newLen = newChildren.length; i < newLen; i++) {
        const newVNode = newChildren[i]
        // 在第一层循环中定义变量find,代表是否在旧的一组子节点中找到可复用的节点，初始值为false，代表没有找到
        let find = false
        for(let j = 0, oldLen = oldChildren.length; j < oldLen; j++) {
          const oldVNode = oldChildren[i]
          if (newVNode.key === oldVNode.key) {
            // 打补丁
            patch(oldVNode, newVNode, container)
            if(j < lastIndex) {
              // 如果当前找到的节点在旧children中的索引小于最大索引值lastIndex
              // 说明该节点对应的真实DOM需要移动
              // 先获取newVNode的前一个vnode,即prevVNode
              const prevVNode = newChildren[i - 1]
              // 如果prevVNode不存在，则说明当前newVNode是第一个节点，它不需要移动
              if (prevVNode) {
                // 由于我们要将newVNode对应的真实DOM移动到prevVNode所对应真实DOM后面，所以我们需要获取prevVNode所对应真实DOM的下一个兄弟节点，并将其作为锚点
                const anchor = prevVNode.el.nextSibling
                // 调用insert方法将newVNode对应的真实DOM插入锚点元素前面
                // 也就是prevVNode对应真实DOM的后面
                insert(newVNode.el, container, anchor)
              }
            } else {
              // 如果当前找到的节点在旧children中的索引不小于最大索引值，则更新lastIndex的值
              lastIndex = j
            }
            break;
          }
        }

        // 如果代码运行到这里，find仍然为false
        // 说明当前newVNode没有旧的一组子节点中找到可复用的节点
        // 也就是说，当前newVNode是新增节点，需要挂载
        if(!find) {
          // 为了将节点挂载到正确位置，我们需要先获取锚点元素
          // 首先获取当前newVNode的前一个vnode节点
          const prevVNode = newChildren[i - 1]
          let anchor = null
          if (prevVNode) {
            // 如果有前一个vnode节点，则使用它的下一个兄弟节点作为锚点节点
            anchor = prevVNode.el.nextSibling
          } else {
            // 如果没有前一个vnode节点，说明即将挂载的新节点是第一个子节点
            // 这时我们使用容器元素的firstChild作为锚点
            anchor = container.firstChild
          }
          patch(null, container, anchor)
        }
      }
    }
  }
```