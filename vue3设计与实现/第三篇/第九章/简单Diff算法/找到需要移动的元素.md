#### 找到需要移动的元素

现在，我们已经能够通过key值找到可复用的节点了。接下来需要思考的是，如何判断一个节点是否需要移动，以及如何移动。

对于第一个问题，我们可以采用逆向思维的方式，先想一想再什么情况下节点不需要移动？答案很简单，当新旧两组子节点的节点顺序不变时，就不需要额外的移动操作。

__在旧的children中寻找具有相同key值节点的过程中, 遇到的最大索引值。如果在后续寻找过程中，存在索引值比当前遇到的最大索引值还小的节点，则意味着该节点需要移动。__

我们可以用lastIndex变量存储整个寻找过程中遇到的最大索引值，如下：

```javascript
  function patchChildren(n1, n2, container) {
    if (typeof n2.children === 'string') {
      // ...
    } else if (Array.isArray(n2.children)) {
      const oldChildren = n1.children
      const newChildren = n2.children

      // 用来存储寻找过程中遇到的最大索引值
      let lastIndex = 0
      for (let i = 0, newLen = newChildren.length; i < newLen; i++) {
        const newVNode = newChildren[i]
        for(let j = 0, oldLen = oldChildren.length; j < oldLen; j++) {
          const oldVNode = oldChildren[i]
          if (newVNode.key === oldVNode.key) {
            // 打补丁
            patch(oldVNode, newVNode, container)
            if(j < lastIndex) {
              // 如果当前找到的节点在旧children中的索引小于最大索引值lastIndex
              // 说明该节点对应的真实DOM需要移动
            } else {
              // 如果当前找到的节点在旧children中的索引不小于最大索引值，则更新lastIndex的值
              lastIndex = j
            }
            break;
          }
        }
      }
    }
  }
```