#### 找到需要移动的元素以及如何移动元素

现在，我们已经能够通过key值找到可复用的节点了。接下来需要思考的是，如何判断一个节点是否需要移动，以及如何移动。如图所示：
![节点顺序不变](../../../images/节点顺序不变.drawio.svg '节点顺序不变')

对于第一个问题，我们可以采用逆向思维的方式，先想一想再什么情况下节点不需要移动？答案很简单，当新旧两组子节点的节点顺序不变时，就不需要额外的移动操作。

__在旧的children中寻找具有相同key值节点的过程中, 遇到的最大索引值。如果在后续寻找过程中，存在索引值比当前遇到的最大索引值还小的节点，则意味着该节点需要移动。__

我们可以用lastIndex变量存储整个寻找过程中遇到的最大索引值，如下：

```javascript
  function patchChildren(n1, n2, container) {
    if (typeof n2.children === 'string') {
      // ...
    } else if (Array.isArray(n2.children)) {
      const oldChildren = n1.children
      const newChildren = n2.children

      // 用来存储寻找过程中遇到的最大索引值
      let lastIndex = 0
      for (let i = 0, newLen = newChildren.length; i < newLen; i++) {
        const newVNode = newChildren[i]
        for(let j = 0, oldLen = oldChildren.length; j < oldLen; j++) {
          const oldVNode = oldChildren[i]
          if (newVNode.key === oldVNode.key) {
            // 打补丁
            patch(oldVNode, newVNode, container)
            if(j < lastIndex) {
              // 如果当前找到的节点在旧children中的索引小于最大索引值lastIndex
              // 说明该节点对应的真实DOM需要移动
              // 先获取newVNode的前一个vnode,即prevVNode
              const prevVNode = newChildren[i - 1]
              // 如果prevVNode不存在，则说明当前newVNode是第一个节点，它不需要移动
              if (prevVNode) {
                // 由于我们要将newVNode对应的真实DOM移动到prevVNode所对应真实DOM后面，所以我们需要获取prevVNode所对应真实DOM的下一个兄弟节点，并将其作为锚点
                const anchor = prevVNode.el.nextSibling
                // 调用insert方法将newVNode对应的真实DOM插入锚点元素前面
                // 也就是prevVNode对应真实DOM的后面
                insert(newVNode.el, container, anchor)
              }
            } else {
              // 如果当前找到的节点在旧children中的索引不小于最大索引值，则更新lastIndex的值
              lastIndex = j
            }
            break;
          }
        }
      }
    }
  }
```

其中insert函数依赖浏览器原生的insertBefore函数：

```javascript
  const renderer = createRenderer({
    // ...
    insert(el, parent, anchor = null) {
      // insertBefore需要锚点元素anchor
      parent.insertBefore(el, anchor)
    }
  })
```
