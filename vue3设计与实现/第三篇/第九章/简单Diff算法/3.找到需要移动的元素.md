#### 找到需要移动的元素

现在，我们已经能够通过key值找到可复用的节点了。接下来需要思考的是，如何判断一个节点是否需要移动，以及如何移动。

对于第一个问题，我们可以采用逆向思维的方式，先想一想再什么情况下节点不需要移动？答案很简单，当新旧两组子节点的节点顺序不变时，就不需要额外的移动操作。

如图所示：
![节点顺序不变](../../../images/节点顺序不变.drawio.svg '节点顺序不变')

上图中，新旧两组子节点的顺序没有发生变化，图中也给出了旧的一组子节点中各个节点的索引：

- key值为1的节点在旧children数组中的索引为0
- key值为2的节点在旧children数组中的索引为1
- key值为3的节点在旧children数组中的索引为2

接着，我们对新旧两组子节点采用之前介绍的更新算法，看看当新旧两组子节点的顺序发生变化时，更新算法具有怎样的特点。

- 第一步：取新的一组子节点中的第一个节点p-1,它的key为1。尝试在旧的一组子节点中寻找具有相同key值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为0。
- 第二步：取新的一组子节点中的第二个节点p-2,它的key为2。尝试在旧的一组子节点中寻找具有相同key值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为1。
- 第三步：取新的一组子节点中的第二个节点p-3,它的key为3。尝试在旧的一组子节点中寻找具有相同key值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为2。

在这个过程中，每一次寻找可复用的节点时，都会记录该可复用节点在旧的一组子节点中的索引值。如果把这些索引值按照先后顺序排列，则可以得到一个序列：0、1、2。这是一个递增的序列，在这种情况下不需要移动任何节点。

再来看一个例子：如下图：
![节点顺序变化](../../../images/节点顺序变化.drawio.svg '节点顺序变化')

同样，根据上图给出的例子再次执行更新算法，看看这一次会有什么不同。

- 第一步：取新的一组子节点中的第一个节点p-3，它的key为3。尝试在旧的一组子节点中寻找具有相同key值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为2。
- 第二步：取新的一组子节点中的第二个节点p-1,它的key为1。尝试在旧的一组子节点中寻找具有相同key值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为0。

- 到了这一步我们发现，索引值递增的顺序被打破了。节点p-1在旧children中的索引是0，它小于节点p-3在旧children中的索引2。说明 __节点p-1在旧children中排在节点p-3的前面，但是在新的children中，它排在节点p-3后面。 因此，我们能够得出一个结论：节点p-1对应的真实DOM需要移动。__

- 第三步：取新的一组子节点中的第二个节点p-2,它的key为2。尝试在旧的一组子节点中寻找具有相同key值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为1。

- 到了这一步我们发现，节点p-2在旧children中的索引是1，它小于节点p-3在旧children中的索引2。说明 __节点p-2在旧children中排在节点p-3的前面，但是在新的children中，它排在节点p-3后面。因此，我们能够得出一个结论：节点p-2对应的真实DOM也需要移动。__ 

如果我们按照先后书序记录在寻找节点过程中所遇到的位置索引，将会得到序列：2、0、1。可以发现，这个序列不具有递增的趋势。

以上就是diff算法在执行更新的过程中，判断节点是否需要移动的方式。


其实可以将节点p-3在旧children中的索引定义为： __在旧的children中寻找具有相同key值节点的过程中, 遇到的最大索引值。如果在后续寻找过程中，存在索引值比当前遇到的最大索引值还小的节点，则意味着该节点需要移动。__

我们可以用lastIndex变量存储整个寻找过程中遇到的最大索引值，如下：

```javascript
  function patchChildren(n1, n2, container) {
    if (typeof n2.children === 'string') {
      // ...
    } else if (Array.isArray(n2.children)) {
      const oldChildren = n1.children
      const newChildren = n2.children

      // 用来存储寻找过程中遇到的最大索引值
      let lastIndex = 0
      for (let i = 0, newLen = newChildren.length; i < newLen; i++) {
        const newVNode = newChildren[i]
        for(let j = 0, oldLen = oldChildren.length; j < oldLen; j++) {
          const oldVNode = oldChildren[i]
          if (newVNode.key === oldVNode.key) {
            // 打补丁
            patch(oldVNode, newVNode, container)
            if(j < lastIndex) {
              // 如果当前找到的节点在旧children中的索引小于最大索引值lastIndex
              // 说明该节点对应的真实DOM需要移动
            } else {
              // 如果当前找到的节点在旧children中的索引不小于最大索引值，则更新lastIndex的值
              lastIndex = j
            }
            break; // 这里需要break
          }
        }
      }
    }
  }
```
