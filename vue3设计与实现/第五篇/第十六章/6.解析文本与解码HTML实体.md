#### 解析文本与解码HTML实体

1.解析文本

给出如下模板：

```js
  const template = `<div>Text</div>`
```

解析器在解析上面这段模板时，会先经过parseTag函数的处理，这会消费标签的开始部分`<div>`。处理完毕后，剩余模板内容为：

```js
  const template = `Text</div>`
```

紧接着，解析器会调用parseChildren函数，开启一个新的状态机来处理这段模板，回顾一下状态机的状态迁移过程：

__初始状态-状态1--->  "<"  ---> 临时状态-状态2 ---> /a-z/i ---> 作为标签节点处理-状态3：parseElement
临时状态-状态2 ---> \<\!--  --->作为注释节点处理-状态4：parseComment
临时状态-状态2 ---> \<\![CDATA[ -->作为CDATA节点处理-状态5：parseCDATA
初始状态-状态1 ---> \{\{ ---> 作为插值节点处理-状态6：parseInterpolation
初始状态-状态1 ---> 任何其他字符 ---> 作为文本节点处理-状态7：parseText__

状态机始于“状态1”。在“状态1”下，读取模板的第一个字符T，由于该字符既不是字符\<，也不是插值定界符\{\{，因此状态机会进入“状态7”，即调用parseText函数处理文本内容。__此时解析器会在模板中寻找下一个\<字符或插值定界符\{\{的位置索引，记为索引I。然后，解析器会从模板的头部到索引I的位置截取内容，这段截取出来的字符串将作为文本节点的内容。__ 以下面的模板内容为例：

```js
  const template = `Text</div>`
```

parseText函数会尝试在这段模板内容中找到第一个出现的字符\<的位置索引。在这个例子中，字符\<的索引值为4。然后，parseText函数会截取介于索引[0, 4)的内容作为文本内容。就是'Text'。

假设模板中存在插值，如下所示：

```js
  const template = `Text-{{ val }}</div>`
```

在处理这段模板时，parseText函数会找到第一个插值定界符\{\{出现的索引位置。在这个例子中，定界符的索引为5。于是，parseText函数会截取介于索引[0, 5)的内容作为文本内容。就是'Text-'。

parseText函数具体实现：

```js
  function parseText(context) {
    // endIndex为文本内容的结尾索引，默认将整个模板剩余内容都作为文本内容
    let endIndex = context.source.length
    // 寻找字符<的位置索引
    let ltIndex = context.souece.indexOf('<')
    // 寻找定界符{{的位置索引
    const delimiterIndex = context.source.indexOf('{{')

    // 取ltIndex和当前endIndex中较小的一个作为新的结尾索引
    if (ltIndex > -1 && ltIndex < endIndex) {
      endIndex = ltIndex
    }
    // 取delimiterIndex和当前endIndex中较小的一个座位新的结尾索引
    if (delimiterIndex > -1 && delimiterIndex < endIndex) {
      endIndex = delimiterIndex
    }

    // 此时endIndex是最终的文本内容的结尾索引，调用slice函数截取文本内容
    const content = content.source.slice(0, endIndex)
    // 消费文本内容
    context.advanceBy(content.length)

    // 消耗文本内容
    context.advanceBy(content.length)

    // 返回文本节点
    return {
      // 节点类型
      type: 'Text',
      // 文本内容
      content
    }
  }
```

由于字符\<与定界符\{\{的出现顺序是未知的。所以我们需要取两者中较小的一个作为文本截取的终点。有了截取终点后，只需要调用字符串的slice函数对字符串进行截取即可。

配合parseText解析如下模板：

```js
  const ast = parse(`<div>Text</div>`)
```

得到如下AST：

```js
  const ast = {
    type: 'Root',
    children: [
      {
        type: 'Element',
        tag: 'div',
        props: [],
        isSelfClosing: false,
        children: [
          // 文本节点
          {
            type: 'Text', content: 'Text'
          }
        ]
      }
    ]
  }
```

解析文本节点本身并不复杂，复杂点在于，我们需要对解析后的文本内容进行HTML实体的解码工作。