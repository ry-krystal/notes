#### 递归下降算法构造模板AST

实现一个更完善的模板解析器，解析器的基本架构模型如下：

```js
  // 定义文本模式，作为一个状态表
  const TextModes = {
    DATA: 'DATA',
    RCDATA: 'RCDATA',
    RAWTEXT: 'RAWTEXT',
    CDATA: 'CDATA'
  }

  // 解析器函数，接收模板作为参数
  function parse(str) {
    // 定义上下文对象
    const context = {
      // source是模板内容，用于在解析过程中进行消费
      source: str,
      // 解析器当前处于文本模式，初始模式为DATA
      mode: TextNodes.DATA
    }
    // 调用parseChildren函数开始进行解析，它返回解析后得到的子节点
    // parseChildren 函数接收两个参数：
    // 第一个参数是上下文对象 context
    // 第二个参数是由父代节点构成的节点栈，初始时栈为空
    const nodes = parseChildren(context, [])

    // 解析器返回Root根节点
    return {
      type: 'Root',
      // 使用nodes作为根节点的children
      chidlren: nodes
    }
  }
```

这段代码的思路与我们之前的模版AST的构建思路有所不同，之前构建模板AST会首先对模板内容进行标记化得到一系列Token,然后根据这些Token构建模板AST。实际上，创建Token与构造模板AST的过程可以同时进行，因为模板和模板AST具有同构的特性。

如下模版：

```html
  <p>1</p>
  <p>2</p>
```

上面这段模板有两个根节点，即两个\<p>标签。parseChildren函数在解析这段模板后，会得到由这两个P节点组成的数组：

```js
  [
    {
      type: 'Element', tag: 'p', children: [/*  */]
    },
    {
      type: 'Element', tag: 'p', children: [/*  */]
    }
  ]
```

之后，这个数组将作为Root根节点的children。

parseChildren函数本质上也是一个状态机，该状态机有多少种状态取决于子节点的类型数量。在模板中，元素的子节点可以是以下几种。(暂时只考虑这些节点)

- 标签节点，例如\<div>
- 文本插值节点，例如{{ val }}
- 普通文本节点，例如：text
- 注释节点，例如 \<!---->
- CDATA节点，例如\<![CDATA[xxx]]>

初始状态 --->  "<"  ---> 临时状态 ---> /a-z/i ---> 作为标签节点处理：parseElement

落实到代码，我们还需结合文本模式，如下所示：

```js
  function parseChildren(context, ancestors) {
    // 定义nodes数组存储子节点，它将作为最终的返回值
    let nodes = []
    // 从上下文对象中取得当前状态，包括模式mode和模板内容source
    const { mode, source } = context

    // 开启while循环，只要满足条件就会一直对字符串进行解析
    while(!isEnd(context, ancestors)) {
      let node
      // 只有DATA模式和RCDATA模式才支持插值节点的解析
      if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        // 只有在DATA模式才支持标签节点的解析
        if (mode === TextModes.DATA && source[0] === '<'){
          if (source[1] === '!') {
            // 注释
            node = parseComment(context)
          } else if (source.startWith('<![CDATA[')) {
            // CDATA
            node = parseCDATA(context, ancestors)
          }
        } else if (source[1] === '/') {
          // 结束标签，这里需要抛出错误，后面会讲
        } else if (/[a-z]/i.test(source[1])) {
          // 标签
          node = parseElement(context, ancestors)
        }
      } else if (source.startsWith('{{')){
        // 解析插值
        node = parseInterpolation(context)
      }
    }

    // node 不存在，说明处于其他模式，即非DATA模式且非RCDATA模式
    // 这里一切内容都作为文本处理
    if (!node) {
      // 解析文本节点
      node = parseText(context)
    }

    // 将节点添加到nodes数组中
    nodes.push(node)
  }
  // 当while循环停止后，说明子节点解析完毕，返回子节点。
  return nodes
}
```
