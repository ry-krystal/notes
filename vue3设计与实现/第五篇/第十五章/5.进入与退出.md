#### 进入与退出

在转换AST节点的过程中，往往需要根据其子节点的情况来决定如何对当前节点进行转换。这就要求父节点的转换操作必须等待所有子节点全部转换完毕后再执行。然而，我们目前设计的转换工作流并不支持这一能力。

对节点的访问分为两个阶段：即 __进入阶段和退出阶段。当转换函数处于进入阶段时，它会先进入父节点，再进入子节点。而当转换函数处于退出阶段时，则会先退出子节点，再退出父节点。这样，只要我们在退出节点阶段对当前访问的节点进行处理，就一定能够保证其子节点全部处理完毕。__

为此，我们需要重新设计转换函数的能力，如下所示：

```js
  function traverseNode(ast, context) {
    context.currentNode = ast
    // 1.增加退出阶段的回调函数数组
    const exitFns = []
    const transforms = context.nodeTransforms
    for(let i = 0; i < transforms.length; i++) {
      // 2. 转换函数可以返回另一个函数，该函数即作为退出阶段的回调函数
      const onExit = transforms[i](context.currentNode, context)
      if (onExit) {
        // 将退出阶段的回调函数添加到exitFns数组中
        exitFns.push(onExit)
      }
      if (!context.currentNode) return
    }

    const children = context.currentNode.children
    if(children) {
      for(let i = 0; i < children.length; i++) {
        context.parent = context.currentNode
        context.childIndex = i
        traverseNode(children[i], context)
      }
    }

    // 在节点处理的最后阶段执行缓存到exitFns中的回调函数
    // 注意，这里我们要反序执行
    let i = exitFns.length
    while(i--) {
      exitFns[i]()
    }
  }
```