#### Teleport 组件实现原理

该组件可以将指定内容渲染到特定容器中，而不受DOM层级的限制。

```html
  <template>
    <Teleport to="body">
      <div class="overlay"></div>
    </Teleport>
  </template>
  <style scoped>
    .overlay {
      z-index: 999;
    }
  </style>
```

首先，我们要将Teleport组件的渲染逻辑从渲染器中分离出来，这么做有两点好处：

- 可以避免渲染器逻辑代码“膨胀”
- 当用户没有使用Teleport组件时，由于Teleport的渲染逻辑被分离，因此可以利用Tree-Shaking机制在最终的bundle中删除Teleport相关的代码，使得最终构建包的体积变小。

完成逻辑分离的工作，要先修改patch函数，如下：

```js
  function patch(n1, n2, container, anchor) {
    if (n1 && n1.type !== n2.type) {
      unmount(n1);
      n1 = null
    }

    const { type } = n2

    if (typeof type === 'string') {
      // ...
    } else if (type === Text) {
      // ...
    } else if (type === Fragment) {
      // ...
    } else if (typeof type === 'object' && type.__isTeleport) {
      // 组件选项中如果存在__isTeleport标识，则它是Teleport组件，调用Teleport组件选项中的process函数将控制权交接出去，传递给process函数的第五个参数是渲染器的一些内部方法
      type.process(n1, n2, container, anchor, {
        path,
        patchChildren,
        unmount,
        move(vnode, container, anchor) {
          insert(vnode.component ? vnode.component.subTree.el : vnode.el, container, anchor)
        }
      })
    } else if (typeof type === 'object' || typeof type === 'function') {
      // ...
    }
  }
```
Teleport组件定义如下：

```js
  const Teleport = {
    __isTeleport: true,
    process(n1, n2, container, anchor) {
      // 在这里处理渲染逻辑
    }
  }
```