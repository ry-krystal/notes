#### props与组件的被动更新

在虚拟DOM层面，组件的props与普通HTML标签属性差别不大。

```js
  <MyComponent title="A Big Title" :other="val" />
```

这段模板对应的虚拟DOM是：

```js
  const vnode = {
    type: MyComponent,
    props: {
      title: 'A big title',
      other: this.val
    }
  }
```

可以看到，模板与虚拟DOM几乎是 '同构'的。 在编写组件时，我们需要显示地指定组件接收哪些prop数据：

```js
  const vnode = {
    type: 'MyComponent',
    props: {
      title: String
    },
    render() {
      return {
        type: 'div',
        children: `count is: ${this.title}` // 访问props数据
      }
    }
  }
```

所以对于一个组件来说，有两部分关于props的内容我们需要关心：

```js
  - 为组件传递的props数据，即组件的vnode.props对象
  - 组件选项对象中定义的props选项，即MyComponent.props对象
```

我们需要结合这两个选项来解析出组件在渲染时需要用到的props数据，具体实现如下：

```js
  function mountComponent(vnode, container, anchor) {
    const componentOptions = vnode.type
    // 从组件选项对象中取出props定义，即propsOption
    const { render, data, props: propsOption,  /* 其他省略 */} = componentOptions

    beforeCreate && beforeCreate()
    const state = reactive(data())
    // 调用resolveProps函数解析出最终的props数据与attrs数据 
    const [props, attrs] = resolveProps(propsOption, vnode.props)

    const instance = {
    state,
    // 将解析出的props数据包装成为shallowReactive并定义到组件实例上
    props: shallowReactive(props),
    isMounted: false,
    subTree: null
    }
    vnode.component = instance
    // 省略部分代码
  }

  function resolveProps(options, propsData) {
    const props = {}
    const attrs = {}
    // 遍历为组件传递的props数据
    for (const key in propsData) {
      if (key in options) {
        // 如果为组件传递的props数据在组件自身的props选项中有定义，则将其视为合法的props
        props[key] = propsData[key]
      } else {
        // 是否将其作为attrs
        attrs[key] = propsData[key]
      }
    }

    // 最后返回props与attrs数据
    return [props, attrs]
  }
```

处理完props数据后，我们再来讨论关于props数据变化的问题。props本质上是父组件的数据，当props数据变化时，会触发父组件重新渲染。假设父组件模板如下：
