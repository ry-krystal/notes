<!DOCTYPE html>
<html>
<head>
<title>Vue3的设计思路.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!--
 * @Description: Vue.js 3的设计思路
 * @version: 1.0
 * @Author: renyong
 * @Date: 2022-07-02 17:24:02
 * @LastEditors: renyong
 * @LastEditTime: 2022-07-03 12:50:03
-->
<h3 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-vuejs-3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">第三章 Vue.js 3的设计思路</h3>
<h5 id="%E6%9C%AC%E7%AF%87%E5%9B%B4%E7%BB%955%E4%B8%AA%E7%AB%A0%E8%8A%82">本篇围绕5个章节：</h5>
<ul>
<li>声明式地描述UI</li>
<li>初识渲染器</li>
<li>组件的本质</li>
<li>模板的工作原理</li>
</ul>
<h4 id="31-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%9C%B0%E6%8F%8F%E8%BF%B0ui">3.1 声明式地描述UI</h4>
<pre class="hljs"><code><div>  &lt;h1 @click=<span class="hljs-string">"handler"</span>&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
  &lt;<span class="hljs-regexp">/h1&gt;
  &lt;script&gt;
    /</span><span class="hljs-regexp">/ h 标签的级别
    let h_hevel = 3
    /</span><span class="hljs-regexp">/ 使用javascript对象来描述UI(虚拟DOM)
    const title = {
      /</span><span class="hljs-regexp">/ 标签名称
      tag: `h${h_hevel}`,
      /</span><span class="hljs-regexp">/ 标签属性
      props: {
        onClick: handler
      },
      /</span><span class="hljs-regexp">/ 子节点
      children: [
        {
          tag: 'span'
        }
      ]
    }
  &lt;/</span>script&gt;
</div></code></pre>
<p>也可以手写渲染函数也就是使用虚拟DOM来描述UI</p>
<pre class="hljs"><code><div> <span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    render() {
      <span class="hljs-keyword">return</span> h(<span class="hljs-string">'h1'</span>, { <span class="hljs-attr">onClick</span>: handler }) <span class="hljs-comment">// 虚拟dom</span>
    }
  }
</div></code></pre>
<p>h 函数的返回值就是一个对象，其作用是让我们编写虚拟DOM变得更轻松。</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    render() {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">tag</span>: <span class="hljs-string">'h1'</span>,
        <span class="hljs-attr">props</span>: {
          <span class="hljs-attr">onClick</span>: handler
        }
      }
    }
  }
</div></code></pre>
<p>一个组件要渲染的内容是通过渲染函数来描述的，也就是上面代码中的render函数，Vue.js会根据组件的render函数的返回值拿到虚拟DOM，然后就把组件的内容渲染出来了</p>
<h4 id="32-%E5%88%9D%E5%A7%8B%E6%B8%B2%E6%9F%93%E5%99%A8">3.2 初始渲染器</h4>
<p>虚拟DOM：其实就是用javascript对象来描述真实的DOM结构</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> vnode = {
  <span class="hljs-attr">tag</span>: <span class="hljs-string">'div'</span>,
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">onClick</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> alert(<span class="hljs-string">'hello'</span>)
  },
  <span class="hljs-attr">children</span>: <span class="hljs-string">'click me'</span>
}
</div></code></pre>
<p>编写一个渲染器，把上面的虚拟DOM渲染为真实DOM:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * <span class="hljs-doctag">@Description</span>: 
 * vnode:虚拟DOM对象
 * container: 一个真实的DOM元素，作为挂载点，渲染器会把虚拟DOM渲染到该挂载点下
 * <span class="hljs-doctag">@return <span class="hljs-type">{*}</span></span>
 * <span class="hljs-doctag">@author</span>: renyong
 */</span>
<span class="hljs-keyword">const</span> renderer = <span class="hljs-function">(<span class="hljs-params">vnode, container</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> tag = vnode.tag
  <span class="hljs-comment">// 使用vnode.tag 作为标签名称创建DOM元素</span>
  <span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createElement(tag)
  <span class="hljs-comment">// 遍历vnode.props，将属性、事件添加到DOM元素</span>
  <span class="hljs-keyword">const</span> props = <span class="hljs-built_in">Object</span>.keys(vnode.props)
  props.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^on/</span>
    <span class="hljs-keyword">if</span> (reg.test(key)) {
      <span class="hljs-comment">// 如果key 以on开头，说明它是事件</span>
      el.addEventListener(
        key.substr(<span class="hljs-number">2</span>).toLowerCase(), <span class="hljs-comment">// 事件名称 onClick ---&gt; click</span>
        vnode.props[key] <span class="hljs-comment">// 事件处理函数</span>
      )
    }
  })

  <span class="hljs-comment">// 处理children</span>
  <span class="hljs-keyword">const</span> children = vnode.children
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> children === <span class="hljs-string">'string'</span>) {
    <span class="hljs-comment">// 如果children是字符串，说明它是元素的文本子节点</span>
    el.appendChild(<span class="hljs-built_in">document</span>.createTextNode(children))
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(children)) {
    <span class="hljs-comment">// 递归地调用renderer函数渲染子节点，使用当前元素el作为挂载点</span>
    children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> renderer(child, el))
  }

  <span class="hljs-comment">// 将元素添加到挂载点下</span>
  container.appendChild(el)
}
renderer(vnode, <span class="hljs-built_in">document</span>.body) <span class="hljs-comment">// body作为挂载点</span>
</div></code></pre>
<h4 id="33-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8">3.3  组件的本质</h4>
<p><strong>组件是一组DOM元素的封装</strong>，这组DOM元素就是组件要渲染的内容</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> MyComponent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">tag</span>: <span class="hljs-string">'div'</span>,
      <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">onClick</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> alert(<span class="hljs-string">'hello'</span>)
      },
      <span class="hljs-attr">children</span>: <span class="hljs-string">'click me'</span>
    }
  }
  <span class="hljs-comment">// 让虚拟DOM对象的tag属性存储组件函数</span>
  <span class="hljs-keyword">const</span> vnode = {
    <span class="hljs-attr">tag</span>: MyComponent
  }
</div></code></pre>
<p>修改renderer函数:</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> renderer = <span class="hljs-function">(<span class="hljs-params">vnode, container</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> tag = vnode.tag
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">'string'</span>) {
      <span class="hljs-comment">// 说明vnode描述的是标签元素</span>
      mountElement(vnode, container)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">'function'</span>) {
      <span class="hljs-comment">// 说明vnode描述的是组件</span>
      mountComponent(vnode, container)
    }
  }
</div></code></pre>
<p>mountElement函数：</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> mountElement = <span class="hljs-function">(<span class="hljs-params">vnode, container</span>) =&gt;</span> {
    <span class="hljs-comment">// 使用vnode.tag作为标签名称创建DOM元素</span>
    <span class="hljs-keyword">const</span> tag = vnode.tag
    <span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createElement(tag)
    <span class="hljs-comment">// 遍历vnode.props, 将属性、事件添加到DOM元素</span>
    <span class="hljs-keyword">const</span> props = <span class="hljs-built_in">Object</span>.keys(vnode.props)
    props.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^on/</span>
      <span class="hljs-keyword">if</span> (reg.test(key)) {
        <span class="hljs-comment">// 如果key是以字符串on 开头，说明它是事件</span>
        el.addEventListener(
          key.substr(<span class="hljs-number">2</span>).toLowerCase(), <span class="hljs-comment">// 事件名称 onClick ---&gt; click</span>
          vnode.props[key] <span class="hljs-comment">// 事件处理函数</span>
        )
      }
    })

    <span class="hljs-comment">// 处理children</span>
    <span class="hljs-keyword">const</span> children = vnode.children
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children === <span class="hljs-string">'string'</span>) {
      <span class="hljs-comment">// 如果chidlren是字符串，说明它是元素的文本子节点</span>
      el.appendChild(<span class="hljs-built_in">document</span>.createTextNode(children))
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(children)) {
      <span class="hljs-comment">// 递归地调用renderer函数渲染子节点，使用当前元素el作为挂载点</span>
      children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> renderer(child, el))
    }

    <span class="hljs-comment">// 将元素添加到挂载点下</span>
    container.appendChild(el)
  }
</div></code></pre>
<p>再看mountComponent是如果实现的：</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> mountComponent = <span class="hljs-function">(<span class="hljs-params">vnode, container</span>) =&gt;</span> {
    <span class="hljs-comment">// 调用组件函数，获取组件要渲染的内容(虚拟DOM)</span>
    <span class="hljs-keyword">const</span> subtree = vnode.tag()
    <span class="hljs-comment">// 递归调用renderer渲染subtree</span>
    renderer(subtree, container)
  }
</div></code></pre>
<p>我们也可以用一个javascript对象来表达一个组件，其返回值代表组件要渲染的内容</p>
<pre class="hljs"><code><div>  <span class="hljs-comment">// MyComponent是一个对象</span>
  <span class="hljs-keyword">const</span> MyComponent = {
    render() {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">tag</span>: <span class="hljs-string">'div'</span>,
        <span class="hljs-attr">props</span>: {
          <span class="hljs-attr">onClick</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> alert(<span class="hljs-string">'hello'</span>)
        },
        <span class="hljs-attr">children</span>: <span class="hljs-string">'click me'</span>
      }
    }
  }
</div></code></pre>
<p>修改渲染器条件：</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> renderer = <span class="hljs-function">(<span class="hljs-params">vnode, container</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> tag = vnode.tag
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">'string'</span>) {
      mountElement(vnode, container)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">'function'</span>) {
      mountComponent(vnode, container)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">'object'</span>) {
      mountComponent(vnode, container)
    }
  }
</div></code></pre>
<p>接下来修改mountComponent:</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> mountComponent = <span class="hljs-function">(<span class="hljs-params">vnode, container</span>) =&gt;</span> {
    <span class="hljs-comment">// vnode.tag 是组件对象，调用它的render函数就得到组件要渲染的内容（虚拟DOM）</span>
    <span class="hljs-keyword">const</span> subtree = vnode.tag.render()
    <span class="hljs-comment">// 递归调用renderer渲染subtree</span>
    renderer(subtree, container)
  }
</div></code></pre>
<h4 id="34-%E6%A8%A1%E6%9D%BF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">3.4 模板工作原理</h4>
<p>Vue.js框架中另一个重要的组成部分：编译器，其作用就是将模板编译成渲染函数：</p>
<pre class="hljs"><code><div>  &lt;div @click=<span class="hljs-string">"handler"</span>&gt;
    click me
  &lt;<span class="hljs-regexp">/div&gt;
</span></div></code></pre>
<p>对于编译器来说，模板就是一个普通的字符串，它会分析该字符串并生成一个功能与之相同的渲染函数“</p>
<pre class="hljs"><code><div>  render() {
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">onClick</span>: handler }, <span class="hljs-string">'click me'</span>)
  }
</div></code></pre>
<p>以我们熟悉的.vue文件为例，一个.vue文件就是一个组件，如下所示：</p>
<pre class="hljs"><code><div>  &lt;template&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handler"</span>&gt;</span>
      click me
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;<span class="hljs-regexp">/template&gt;

  &lt;script&gt;
    export default {
      data() {/</span>*  *<span class="hljs-regexp">/},
      methods: {
        handler() {/</span>*  *<span class="hljs-regexp">/}
      }
    }
  &lt;/</span>script&gt;
</div></code></pre>
<p>其中tempalte标签里面的内容就是模板内容，编译器会把模板内容编译成渲染函数并添加到&lt;script&gt;标签块的组件对象上，所以最终在浏览器里运行的代码就是：</p>
<pre class="hljs"><code><div>   <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
      data() {<span class="hljs-comment">/*  */</span>},
      <span class="hljs-attr">methods</span>: {
        handler() {<span class="hljs-comment">/*  */</span>}
      },
      render() {
        <span class="hljs-keyword">return</span> h(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">onClick</span>: handler }, <span class="hljs-string">'click me'</span>)
      }
    }
</div></code></pre>
<p>所以，无论是使用模板还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的，然后渲染器再把渲染函数返回的虚拟DOM渲染成真实DOM，这就是模板工作原理，也就是Vue.js渲染页面的流程</p>
<p>模板编译流程：模块----&gt;编译器----&gt;渲染函数(render)---&gt;渲染器(renderer) ----&gt; 真实DOM</p>

</body>
</html>
