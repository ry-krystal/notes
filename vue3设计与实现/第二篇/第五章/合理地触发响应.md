<!--
 * @Description: 
-->
#### 合理地触发响应
在如何代理对象中，处理了很多边界条件。例如我们需要明确知道操作的类型是'ADD'还是'SET',亦或是其他操作类型，从而正确地触发响应。但是想要合理地触发响应，还有很多工作要。

首先，我们来看第一个问题，即当值没有发生变化时，应该不需要触发响应才对：
```javascript
  const obj = { foo: 1 }
  const p = new Proxy(obj, {/*  */})

  effect(() => {
    console.log(p.foo)
  })

  // 设置p.foo的值,但值没有变化
  p.foo = 1
```
如上面的代码所示，p.foo的初始值为1，当为p.foo设置新的值时，如果值没有变化，则不需要触发响应。为例满足需求，我们需要修改set拦截函数的代码，在调用trigger函数触触发响应之前，需要检查值是否真的发生了变化：
```javascript
  const p = new Proxy(obj, {
    set(target, key, newVal, receiver) {
      // 先获取旧值
      const oldVal = target[key]

      const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
      const res = Reflect.set(target, key, newVal, receiver)
      // 比较新值与旧值，只要当不全等的时候才触发响应
      if (oldVal !== newVal) {
        trigger(target, key, type)
      }

      return res
    }
  })
```
然而，仅仅进行全等比较是有缺陷的，这体现在对NaN的处理上。我们知道NaN与NaN进行全等比较总会得到false:
```javascript
  NaN === NaN // false
  NaN !== NaN // true
```
换句话说，如果p.foo的初始值是NaN,并且后续又为其设置了NaN作为新值，那么仅仅进行全等比较的缺陷就暴露了：
```javascript
  const obj = { foo: NaN }
  const p = new Proxy(obj, {/*  */})

  effect(() => {
    console.log(p.foo)
  })

  // 仍然会触发响应，因为NaN !== NaN 为true
  p.foo = NaN
```
这仍然会触发响应，并导致不必要的更新。为了解决这个问题，我们需要再加一个条件，即在新值和旧值不全等的情况下，要保证他们都不是NaN:
```javascript
  const p = new Proxy(obj, {
    set(target, key, newVal, receiver) {
      //先获取旧值
      const oldVal = target[key]
      const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
      const res = Reflect.set(target, key, newVal, receiver)
      // 比较新值与旧值，只有当它们不全等，并且都不是NaN的时候才触发响应
      if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {
        trigger(target, key, type)
      }
      return res
    }
  })
```
这样我们解决了NaN的问题。

但想要合理的触发响应，仅仅处理NaN的问题还不够，接下来，我们讨论一种从原型上继承属性的情况。为了后续讲解方便，我们需要封装一个reactive函数，该函数接收一个对象作为参数，并返回为其创建的响应式数据：
```javascript
  function reactive(obj) {
    return new Proxy(obj, {
      // ...
    })
  }
```
可以看到，reactive只是对Proxy进行了一层封装。
```javascript
  const obj = {}
  const proto = { bar: 1 }
  const child = reactive(obj)
  const parent = reactive(proto)

  // 使用parent作为child的原型
  Object.setPrototypeOf(child, parent)
  effect(() => {
    console.log(child.bar) // 1
  })
  // 修改child.bar的值
  child.bar = 2 // 会导致副作用函数重新执行两次
```