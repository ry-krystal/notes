<!--
 * @Description: 原始值的响应式方案
-->
#### 原始值的响应式方案
原始值值的是Boolean、Number、BigInt、String、Symbol、undefined和null等类型的值。在JavaScript中，原始值是按值传递的，而非按引用传递。这意味着，如果一个函数接收原始值作为参数，那么形参和实参之间没有引用关系，它们是两个完全独立的值，对形参的修改不会影响实参。另外，JavaScript中的Proxy无法提供对原始值的代理，因此想要将原始值变成响应式数据，就必须对其做一层包裹，也就是我们接下来的ref。

1. 引入ref的概念
由于Proxy的代理目标必须是非原始值，所以我们没有任何手段拦截对原始值的操作，例如：
```javascript
  let str = 'vue'
  // 无法拦截对值的修改
  str = 'vue3'
```
对于这个问题，我们能想到的唯一办法是，使用一个非原始值去‘包裹’原始值，例如使用一个对象包裹原始值：
```javascript
  const wrapper = {
    value: 'vue'
  }
  // 可以使用Proxy代理wrapper，间接实现对原始值的拦截
  const name = reactive(wrapper)
  name.value // vue
  // 修改值可以触发响应
  name.value = 'vue3'
```
但这样做会导致两个问题：
- 用户为了创建一个响应式的原始值，不得不顺带创建一个包裹对象；
- 包裹对象由用户定义，而这意味着不规范。用户可以随意命名，例如：wrapper.value、 wrapper.val都是可以的。

为了解决这两个问题，我们可以封装一个函数，将包裹对象的创建工作都封装到该函数中：
```javascript
  // 封装一个ref函数
  function ref(val) {
    // 在ref函数内部创建包裹对象
    const wrapper = {
      value: val
    }
    // 将包裹对戏那个变成响应式
    return reactive(wrapper)
  }
```