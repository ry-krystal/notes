<!--
 * @Description: 
-->
<!--
 * @Description: 原始值的响应式方案
-->
#### 原始值的响应式方案
原始值值的是Boolean、Number、BigInt、String、Symbol、undefined和null等类型的值。在JavaScript中，原始值是按值传递的，而非按引用传递。这意味着，如果一个函数接收原始值作为参数，那么形参和实参之间没有引用关系，它们是两个完全独立的值，对形参的修改不会影响实参。另外，JavaScript中的Proxy无法提供对原始值的代理，因此想要将原始值变成响应式数据，就必须对其做一层包裹，也就是我们接下来的ref。

1. 引入ref的概念
由于Proxy的代理目标必须是非原始值，所以我们没有任何手段拦截对原始值的操作，例如：
```javascript
  let str = 'vue'
  // 无法拦截对值的修改
  str = 'vue3'
```
对于这个问题，我们能想到的唯一办法是，使用一个非原始值去‘包裹’原始值，例如使用一个对象包裹原始值：
```javascript
  const wrapper = {
    value: 'vue'
  }
  // 可以使用Proxy代理wrapper，间接实现对原始值的拦截
  const name = reactive(wrapper)
  name.value // vue
  // 修改值可以触发响应
  name.value = 'vue3'
```
但这样做会导致两个问题：
- 用户为了创建一个响应式的原始值，不得不顺带创建一个包裹对象；
- 包裹对象由用户定义，而这意味着不规范。用户可以随意命名，例如：wrapper.value、 wrapper.val都是可以的。

为了解决这两个问题，我们可以封装一个函数，将包裹对象的创建工作都封装到该函数中：
```javascript
  // 封装一个ref函数
  function ref(val) {
    // 在ref函数内部创建包裹对象
    const wrapper = {
      value: val
    }
    // 将包裹对戏那个变成响应式
    return reactive(wrapper)
  }
```
我们把创建wrapper对象的工作封装到ref函数内部，然后使用reactive函数将包裹对象变成响应式数据并返回。这样我们就解决了上述两个问题。运行如下测试代码：
```javascript
  // 创建原始值的响应式数据
  const refVal = ref(1)

  effect(() => {
    // 在副作用函数内通过value属性获取原始值
    console.log(refVal.value)
  })
  // 修改值能够触发副作用函数重新执行
  refVal.value = 2
```
现在是否一切都完美了呢？并不是，接下来我们面临的第一个问题是，如何区分refVal到底是原始值的包裹对象，还是一个非原始值的响应式数据，如以下代码所示：
```javascript
  const refVal1 = ref(1)
  const refVal2 = reactive({ value: 1 })
```
refVal1和refVal2有什么区别呢？从我们实现来看，它们没有任何区别。但是，我们有必要区分一个数据到底是不是ref,因为涉及自动脱ref能力。
要想区分一个数据是否是ref很简单：
```javascript
  function ref(val) {
    const wrapper = {
      value: val
    }
    // 使用Object.defineProperty在wrapper对象上定义一个不可枚举的属性__v_isRef, 并且值为true
    Object.defineProperty(wrapper, '__v_isRef', {
      value: true
    })

    return reactive(wrapper)
  }
```
我们使用Object.defineProperty为包裹对象wrapper定义了一个不可枚举且不可写的属性__v_isRef，它的值为true,代表这个对象是一个ref,而非普通对象。