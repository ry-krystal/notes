#### 模块机制

1. 在node中引入模块，需要经历如下3个步骤：
  
- 路径分析
- 文件定位
- 编译执行
  
在Node中，模块分为两类：一类是Node提供的模块，也叫核心模块；另一类是用户编写的模块，叫作文件模块。

- 核心模块部分在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。

2. 优先从缓存加载

 - 与前端浏览器会缓存静态脚本文件以提高性能一样，node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而node缓存的是编译和执行之后的对象。
 - 无论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。
  
        2.1 路径分析和文件定位

        因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异。

        1. 模块标识符分析
        - 核心模块、如http、fs、path等。
        - .或..开始的相对路径文件模块。
        - 以/开始的绝对路径文件模块。
        - 非路径形式的文件模块，如自定义的connect模块。

        - 核心模块：优先级仅次于缓存加载
        - 路径形式的文件模块：以.或者..和/开始的标识符，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。其加载速度慢于核心模块。
        - 自定义模块：查找时最费时的，也是所有方式中最慢的一种。

       2.2 文件定位
        
        从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析，目录和包的处理。

        - 文件扩展名分析

        require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJs模块规范也允许在标识符中不包含文件扩展名，这种情况下，node会按.js、.json和.node的次序补足扩展名，依次尝试。

        在尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷。

        - 目录分析和包