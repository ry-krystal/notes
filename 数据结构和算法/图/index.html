<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>图</title>
  </head>
  <body>
    <script>
      /* 
        图
        图是由一组边连接的节点(或顶点)。

        一个图G=(V,E)由以下元素组成。
        V: 一组顶点
        E: 一组边，连接V中的顶点

        邻接表：是由图中每个顶点的相邻顶点列表组成。存在好几种方式来表示这种数据结构。
        我们可以用列表(数组)、链表，甚至是散列表或是字典表示相邻顶点列表。我们将使用邻接表表示法
      */

      const defaultToString = (item) => {
        if (item === null) {
          return "NULL";
        } else if (item === undefined) {
          return "UNDEFINED";
        } else if (typeof item === "string" || item instanceof String) {
          return `${item}`;
        }
        return item.toString();
      };

      class ValuePair {
        constructor(key, value) {
          this.key = key;
          this.value = value;
        }
        toString() {
          return `[#${this.key}: ${this.value}]`;
        }
      }

      // 字典类
      class Dictionary {
        constructor(toStrFn = defaultToString) {
          this.toStrFn = toStrFn;
          this.table = {};
        }

        // 检测一个键是否存在于字典中
        hasKey(key) {
          return this.table[this.toStrFn(key)] != null;
        }

        // 在字典和ValuePair类中设置键和值
        set(key, value) {
          if (key != null && value != null) {
            const tableKey = this.toStrFn(key);
            this.table[tableKey] = new ValuePair(key, value);
            return true;
          }
          return false;
        }

        // 从字典移除一个值
        remove(key) {
          if (this.hasKey(key)) {
            delete this.table[this.toStrFn(key)];
            return true;
          }
          return false;
        }

        // 从字典中检索一个值
        get(key) {
          const valuePair = this.table[this.toStrFn(key)];
          return valuePair == null ? undefined : valuePair.value;
        }

        // 获取key和value
        keyValues() {
          return Object.values(this.table);
        }

        // 获取keys
        keys() {
          return this.keyValues().map((valuePair) => valuePair.key);
        }

        // 获取values
        values() {
          return this.keyValues().map((valuePair) => valuePair.value);
        }

        // 用forEach迭代字典中每个键值对
        forEach(callbackFn) {
          const valuePairs = this.keyValues();
          for (let i = 0; i < valuePairs.length; i++) {
            const result = callbackFn(valuePairs[i].key, valuePairs[i].value);
            if (result === false) break;
          }
        }

        // 字典的长度
        size() {
          return Object.keys(this.table).length;
        }

        // 字典是否为空
        isEmpty() {
          return this.size() === 0;
        }

        // 清空字典内容
        clear() {
          this.table = {};
        }

        // 转化为toString
        toString() {
          if (this.isEmpty()) return "";
          const valuePairs = this.keyValues();
          let objectString = `${valuePairs[0].toString()}`;
          for (let i = 1; i < valuePairs.length; i++) {
            objectString = `${objectString},${valuePairs[i].toString()}`;
          }
          return objectString;
        }
      }

      /* 
        创建Graph类
        可以接收一个参数来表示图是否有向，默认情况下，图是无向的。
        可以使用一个数组来存储图中所有顶点的名字，以及一个字典来存邻接表。
        字典将会使用顶点的名字作为键，邻接顶点列表作为值。

        接下来实现两个方法：1. 一个用来向图中添加一个新的顶点(因为图实例化之后是空的) 2.另外一个方法用来添加顶点之间的边。
       
      */
      // 创建Graph类
      class Graph {
        constructor(isDirected = false) {
          this.isDirected = isDirected;
          this.vertices = []; // 存储顶点的名字
          this.adjList = new Dictionary(); // 用字典存储邻接表
        }

        // 添加顶点
        addVertex(v) {
          if (!this.vertices.includes(v)) {
            this.vertices.push(v);
            // 设置顶点v作为键对应的字典值为一个空数组
            this.adjList.set(v, []);
          }
        }

        // 添加边 - 接收两个顶点作为参数，也就是我们要建立连接的两个顶点，在连接顶点之前，需要验证顶点是否存在于图中
        addEdge(v, w) {
          if (!this.adjList.get(v)) {
            // 添加的顶点没有对应的邻接表，说明没有这个顶点，就添加
            this.addVertex(v);
          }
          if (!this.adjList.get(w)) {
            this.addVertex(w);
          }
          this.adjList.get(v).push(w);
          if (!this.isDirected) {
            // 如果是无向图
            this.adjList.get(w).push(v);
          }
        }

        // 返回顶点列表
        getVertices() {
          return this.vertices;
        }

        // 返回邻接表
        getAdjList() {
          return this.adjList;
        }

        toString() {
          let s = "";
          for (let i = 0; i < this.vertices.length; i++) {
            s += `${this.vertices[i]} -> `;
            const neighbors = this.adjList.get(this.vertices[i]);
            for (let j = 0; j < neighbors.length; j++) {
              s += `${neighbors[j]}`;
            }
            s += "\n";
          }
          return s;
        }
      }

      // 测试代码
      const graph = new Graph();
      // 顶点
      const myVertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];
      for (let i = 0; i < myVertices.length; i++) {
        graph.addVertex(myVertices[i]);
      }
      graph.addEdge("A", "B");
      graph.addEdge("A", "C");
      graph.addEdge("A", "D");
      graph.addEdge("C", "D");
      graph.addEdge("C", "G");
      graph.addEdge("D", "G");
      graph.addEdge("D", "H");
      graph.addEdge("B", "E");
      graph.addEdge("B", "F");
      graph.addEdge("E", "I");

      console.log(graph.toString());
    </script>
  </body>
</html>
