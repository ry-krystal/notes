<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 
        给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
        请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
        注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
      */
      const merge = (nums1, m, nums2, n) => {
        while (n > 0) {
          nums1[m + n - 1] =
            (m < 1 || nums1[m - 1]) <= nums2[n - 1] ? nums2[--n] : nums1[--m];
        }
      };

      merge([0], 0, [1], 1);

      function TreeNode(val) {
        this.val = val;
        this.left = null;
        this.right = null;
      }

      const buildBST = (nums, start, end) => {
        if (start > end) return;
        // 获取数组的中间索引
        const mid = nums.length >> 1;
        // console.log(mid);
        // 创建根节点
        const root = new TreeNode(nums[mid]);
        // 创建左子树
        root.left = buildBST(nums, start, mid - 1);
        // 创建右子树
        root.right = buildBST(nums, mid + 1, right);

        return root;
      };

      /**
       * @param {number[]} nums
       * @return {TreeNode}
       */
      var sortedArrayToBST = function (nums) {
        return buildBST(nums, 0, nums.length - 1);
      };

      console.log(sortedArrayToBST([-10, -3, 0, 5, 9]));
    </script>
  </body>
</html>
