#### Mutation 阶段

对于 HostComponent, Mutation 阶段的工作主要是进行 DOM 元素的增、删、改。其他类型的 component 在 Mutation 阶段后面会涉及到。

4.4.1 删除 DOM 元素

前面提到，一些子阶段在 commitXXXEffects_begin 向下遍历过程中还会执行其特有的操作。Mutation 阶段特有的操作是删除 DOM 元素：

```js
function commitMutationEffects_begin(root) {
  while (nextEffect !== null) {
    const fiber = nextEffect;
    // 删除DOM 元素
    const deletions = fiber.deletions;
    if (deletions !== null) {
      for (let i = 0; i < deletions.length; i++) {
        const childToDelete = deletions[i];
        try {
          commitDeletion(root, childToDelete, fiber);
        } catch (error) {
          // ...
        }
      }
    }

    const child = fiber.child;
    if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
      // 省略辅助方法
      nextEffect = child;
    } else {
      commitMutationEffects_complete(root);
    }
  }
}
```

其中 fiber.deletions 是一个数组，数组中的项是在 render 阶段 beginWork 执行 reconcile 操作时，发现需要删除”子 fiberNode 对应的 DOM 元素“ 时，执行 deleteChild 方法添加的。

执行删除操作的方法是 commitDeletion, 其完整逻辑比较复杂。原因在于--当删除一个 DOM 元素时，还需要考虑：

- 其子树中所有组件的 unmount 逻辑。
- 其子树中所有 ref 属性的卸载操作。
- 其子树中所有 Effect 相关 Hook(比如 useLayoutEffect)的 destroy 回调执行
  比如，考虑如下 jsx 结构，当删除最外层 DIV HostComponent 时，还需要考虑：

  - 执行 SomeClassComponent 中的 componentWillUnmount 方法；
  - 执行 SomeFunctionComponent 中的 useEffect、useLayoutEffect 的 destroy 方法；
  - divRef 的卸载操作。

```jsx
<div>
  <SomeClassComponent />
  <div ref={divRef}>
    <SomeFunctionComponent />
  </div>
</div>
```

所以整个删除操作是以 DFS 的顺序，遍历子树的每个 fiberNode，执行对应操作。
