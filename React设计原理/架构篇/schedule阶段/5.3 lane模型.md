#### lane 模型

从”产生交互“到 render 阶段流程概览如下图，其中小循环、大循环的概念。

5.1 实现了该流程的简易版本，与 React 实际情况对比，其中：

- “不同按钮对应不同优先级”对应“不同交互产生不同优先级”。
- “schedule 方法选出优先级”对应 schedule 阶段；
- “perform 方法执行 work”对应 render 阶段。

简易版本中，schedule 方法会选择一个优先级(最高优先级)。实际情况会更复杂，React 在选出一个优先级的同时，会再选择一批优先级。选出的这个优先级会作为“Schedule 调度的优先级”，选出的一批优先级则会参与 render 阶段。

React 会再“选出一批优先级”的原因与“状态的计算”有关。在 FC 中，状态的定义与修改方式如下：

```js
// 定义状态num
const [num, updateNum] = useState(0);

// 修改状态的方式1
updateNum(2);
// 修改状态的方式2
updateNum((num) => num + 1);
```

执行“修改状态的方式”后，会生成 Update 这一数据结构，不同的 update 拥有不同的优先级。所以“状态的当前值”通常是由“一到多个相同或不同优先级的 update”计算得到的。方式 1 生成的 update 在参与状态计算时，与其他 update 没有依赖关系，比如：

- num 为 1，经由“值为 2 的 update”计算后为 2。
- num 为 100，经由“值为 2 的 update”计算后为 2。

方式 2 生成的 update 在参与状态计算时，与之前的 update 有依赖关系，比如：

- num 为 1，经由“值为 num => num + 1 的 update”计算后为 2；
- num 为 100， 经由“num => num + 1 的 update”计算后为 101；

所以，由于 update 之间存在依赖关系，为了保证“状态的计算结果”符合预期，React 会在更新优先级的基础上再选出一批优先级，共同参与状态计算。

5.3.1 React 与 Scheduler 的结合

由于 React 与 Scheduler 的优先级并不通用，因此 React 选出优先级提交给 Scheduler 前会进行转换。我们已经了解，Scheduler 拥有五中优先级(NoPriority 除外)：

```js
export const NoPriority = 0;
export const ImmediatePriority = 1;
export const UserBlockingPriority = 2;
export const NormalPriority = 3;
export const LowPriority = 4;
export const IdlePriority = 5;
```

作为一个独立的包，考虑到通用性，Scheduler 并不与 React 通用一套优先级体系。React 有四种优先级：

```js
export const DiscreteEventPriority = SyncLane;
export const ContinuousEventPriority = InputContinuousLane;
export const DefaultEventPriority = DefaultLane;
export const IdleEventPriority = IdleLane;
```

具体来说，在 React 中，“不同交互对应的事件回调中产生的 update”会拥有不同优先级。由于优先级与“事件”相关，所以被称为 EventPriority(事件优先级)，其中：

- DiscreteEventPriority 对应“离散事件的优先级”，例如 click、input、focus、blur、touchstart 等事件都是离散触发的。
- ContinuousEventPriority 对应“连续事件的优先级”，例如 drag、mousemove、scroll、touchmove、wheel 等事件都是连续触发的。
- DefaultEventPriority 对应“默认的优先级”，例如通过计时器周期性触发更新，这种情况产生的 update 不属于“交互产生的 update”, 所以优先级是默认的优先级；
- IdleEventPriority 对应“空闲情况的优先级”。

从 React 到 Scheduler,优先级需要经过如下两次转换。
(1)将 lanes 转换为 EventPriority，涉及的方法如下。经过转换，返回的是 EventPriority:

```js
function lanesEventPriority(lanes) {
  // 获取lanes中优先级最高的lane
  let lane = getHighestPriorityLane(lanes);
  // 如果优先级高于DiscreteEventPriority,返回DiscreteEventPriority
  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
    return DiscreteEventPriority;
  }

  // 如果优先级高于ContinuousEventPriority,返回ContinuousEventPriority
  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
    return ContinuousEventPriority;
  }

  // 如果包含“非Idle的任务”,返回DefaultEventPriority
  if (includesNoIdleWork(lane)) {
    return DefaultEventPriority;
  }

  // 返回IdleEventPriority
  return IdleEventPriority;
}
```

(2) 将 EventPriority 转换为 Scheduler 优先级，具体逻辑如下：

```js
let schedulerPriorityLevel;

// 将lanes 转换为EventPriority
switch (lanesToEventPriority(nextLanes)) {
  // DiscreteEventPriority对应ImmediatePriority
  case DiscreteEventPriority:
    schedulerPriorityLevel = ImmediatePriority;
    break;
  // ContinuousEventPriority对应UserBlockingPriority
  case ContinuousEventPriority:
    schedulerPriorityLevel = UserBlockingPriority;
    break;
  // DefaultEventPriority对应NormalPriority
  case DefaultEventPriority:
    schedulerPriorityLevel = NormalPriority;
    break;
  // IdleEventPriority对应IdlePriority
  case IdleEventPriority:
    schedulerPriorityLevel = IdleEventPriority;
    break;
  // 默认NormalPriority
  default:
    schedulerPriorityLevel = NormalPriority;
    break;
}
```

举例说明，在 onClick 回调中触发的更新，属于 DiscreteEventPriority,对应 Scheduler 中的 ImmediatePriority。这意味着“点击事件中触发的更新会同步处理”。

以上是从 React 到 Scheduler 优先级的转换。从 Scheduler 到 React 优先级的转换逻辑如下：

```js
// 获取当前Scheduler调度的优先级
let schedulerPriority = getCurrentPriorityLevel();

switch (schedulerPriority) {
  // ImmediatePriority对应DiscreteEventPriority
  case ImmediatePriority:
    return DiscreteEventPriority;
  // UserBlockingPriority对应ContinuousEventPriority
  case UserBlockingPriority:
    return ContinousEventPriority;

  // NormalPriority、LowPriority对应DefaultEventPriority
  case NormalPriority:
  case LowPriority:
    return DefaultEventPriority;

  // IdlePriority对应IdleEventPriority
  case IdlePriority:
    return IdleEventPriority;
  // 默认为DefaultEventPriority
  default:
    return DefaultEventPriority;
}
```

5.3.2 基于 expirationTime 算法

优先级算法需要解决的最基本的两个问题是：

(1). 从"众多 update 包含的优先级"中选出一个优先级。
(2). 表达“批”的概念。

Scheduler 已经有针对第一个问题的解决方案：不同优先级对应不同的 timeout，最终对应不同的 expirationTime, task.expirationTime 作为 task 的排序依据。最初 React 沿用了类似的算法，”update 的优先级“与”触发事件的当前时间“及”优先级对应的延迟时间相关“：

```js
update.expirationTime = MAX_SIGNED_31_BIT_INT - (currentTime + taskPriority);
```

例如，高优先级 update u1、低优先级 update u2 的 taskPriority 分别是 0、200，则 u1.expirationTime > u2.expirationTime，代表 u1 优先级更高：

```js
// u1.expirationTime > u2.expirationTime
MAX_SIGNED_31_BIT_INT - (currentTime + 0) >
  MAX_SIGNED_31_BIT_INT - (currentTime + 200);
```

"基于 expirationTime 的优先级算法"简单易懂：每当进入 schedule 阶段，会选出”优先级最高的 update“进行调度。

由于 schedule 阶段的存在，不同的 fiberNode 上可能存在多个 update，这些 update 对应的优先级可能不同，React 会按”批“更新，即：经由 schedule 阶段优先级算法决定的优先级，及“与该优先级同一批的优先级”，它们对应的 update 会共同参与状态计算。所以，需要一种算法能够 **基于某一个优先级，计算出属于同一批的所有优先级。** 基于 expirationTime 的模型算法如下：

```js
const isUpdateIncludedInBatch = priorityOfUpdate >= priorityOfBatch;
```

priorityOfUpdate 代表“update 的优先级”， priorityOfBatch 代表“批对应的优先级下限”。 “大于 priorityOfBatch 的 update”都会被划分为同一批。
