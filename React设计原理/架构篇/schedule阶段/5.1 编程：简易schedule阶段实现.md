#### 简易 schedule 阶段实现

Schedule 是一个独立的包。为了保证通用性，React 并没有与 Schedule 共用一套优先级。

下面一个示例，改示例用 work 这一数据结构代表“一份工作”，work.count 代表“这份工作要重复做某件事的次数”。在示例中要重复做的事是“执行 insertItem 方法，向页面插入 HTMLSpanElement”。

```js
const insertItem = (content) => {
  const ele = document.createElement("span");
  ele.innerText = `${content}`;
  contentBox.appendChild(ele);
};
```

如下 work 代表“执行 100 次 insertItem 方法，向页面插入 100 个 HTMLSpanElement”：

```js
const work1 = {
  count: 100,
};
```

如果用 work 类比“React 的一次更新”，用 work.count 类比“这次更新 render 阶段需要处理组件的数量”，则下面的示例可以类比“React 更新流程”。

接下来实现第一版的调度系统，流程如下所示，包括三个步骤：

1. 向 workList 队列(用于保存所有 work)插入 work;
2. schedule 方法从 workList 中取出 work，传递给 perform 方法
3. perform 方法执行完 work 的所有工作后重复步骤 2

![第一版调度流程](../images/第一版调度流程.drawio.svg "第一版调度流程")

代码如下：

```js
// 保存所有work的队列
const workList = [];

// 调度
function schedule() {
  // 从队列末尾取出一个work
  const curWork = workList.pop();

  if (curWork) {
    perform(curWork);
  }
}

// 执行
function performWork(work) {
  while (work.count) {
    work.count--;
    insertItem();
  }

  schedule();
}
```

为按钮绑定点击交互事件。至此，最基本的调度系统已经完成，点击 button 即可插入 100 个 HTMLSpanElement:

```js
button.onclick = () => {
  workList.unshift({
    count: 100,
  });

  schedule();
};
```
