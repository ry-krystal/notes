<!--
 * @Description: 受控组件和非受控组件
-->
#### 受控组件和非受控组件
1. 受控组件
React官方推荐使用受控组件。总结下React受控组件更新state的流程：
 - 可以通过在初始state中设置表单的默认值。
 - 每当表单的值发生变化时，调用onChange事件处理器。
 - 事件处理器通过合成事件对象e拿到改变后的状态，并更新应用的state
 - setState触发视图的重新渲染，完成组件值的更新。

 在React中，数据时单向流动的。从示例中，我们能看出来表单的数据源于组件的state,并通过props传入，这也成为单向数据绑定。然后，我们又通过onChange事件处理器将新的表单数据写回到组件的state,完成双向数据绑定。

 ```javascript
  hanleChange(e) {
    this.setState({
      value: e.target.value.substring(0, 140).toUpperCase()
    })
  }
 ```
 在React内部拦截了浏览器的原生事件，这得益于Virtual DOM以及合成事件系统。
<br />
2. 非受控组件
 React也支持非受控组件，简单地说，如果有一个表单组件没有value props（单选按钮和复选框对应的是 checked prop）时，就可以称为非受控组件，你可以使用defaultValue和defaultChecked prop 来表示组件的默认状态。

```javascript
  import React, { Component } from 'react';
  
  class App extends Component {
    constructor(props) {
      super(props);
      this.handleSubmit = this.handleSubmit.bind(this)
    }

    handleSubmit(e) {
      e.preventDefault()

      // 这里使用React提供的ref prop来操作DOM
      // 当然，也可以使用原生的接口，如document.querySelector
      const { vlaue } = this.refs.name
      console.log('value', value);
    }

    render() {
      return (
        <form onSubmit={ this.handleSubmit }>
          <input ref="name" type="text" defaultValue="hangzhou" />
          <button type="submit">Submit</button>
        </form>
      )
    }
  }
```
__在React中，非受控组件是一种反模式，它的值不受组件自身的state或props控制。__

3. 对比受控组件和非受控组件
受控组件和非受控组件到底各自有什么特点和适用场景呢？
- 性能上的问题，在受控组件中，每次表单的值发生变化时，都会调用一次onChange事件处理器，这确实会有一些性能上的损耗。虽然使用非受控不会出现这些问题，但仍然不提倡在React中使用非受控组件。这个问题可以通过Flux/Redux应用架构等方式来达到统一组件状态的目的。
- 是否需要事件绑定, 使用受控组件最令人头疼的就是，我们需要为每个组件绑定一个change事件，并且定义一个事件处理器来同步表单值和组件的状态，这是一个必要条件。当然，在某些简单的情况下，也可以使用一个事件处理器来处理多个表单域：

```javascript
  import React, { Component } from 'react'

  class FormApp extends Component {
    constructor(props) {
      super(props)

      this.state = {
        name: '',
        age: 18
      }
    }

    hanleChange(name, e) {
      const { value } = e.target
      // 这里只能处理直接赋值这种简单的情况，复杂的处理建议使用switch(name)语句
      this.setState({
        [name]: value
      })
    }

    render() {
      const { name, age } = this.state
      return (
        <div>
          <input value={name} onChange={this.hanleChange.bind(this, 'name')} />
          <input value={age} onChange={this.hanleChange.bind(this, 'age')} />
        </div>
      )
    }
  }
```


