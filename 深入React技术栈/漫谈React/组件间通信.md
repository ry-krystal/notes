<!--
 * @Description: 组件间通信
-->
#### 组件间通信
  React 是以组合组件的形式组织的，组件因为彼此是相互独立的，从传递信息的内容上看，几乎所有类型的信息都可以实现传递，例如字符串、数组、对象、方法或自定义组件等。所以，在嵌套关系上，就会有3种不同的可能性：父组件向子组件通信、子组件向父组件通信和没有嵌套关系的组件之间通信。

  1. 父组件向子组件通信
  react数据流动是单向的，父组件向子组件的通信也是最常见的方式。父组件通过props向子组件传递需要的信息。我们通过一个列表组件List,并将其中的项抽象成ListItem组件来温习这个过程：
  ```javascript
    import React, { Component } from 'react'

    function ListItem({ value }) {
      return (
        <li>
          <span>{value}</span>
        </li>
      )
    }

    function List({ list, title }) {
      return (
        <div>
          <ListTitle title={ title }/>
          <ul>
            {
              list.map((entry, index) => (
                <ListItem key={`list-${index}`}  value={entry.text} />
              ))
            }
          </ul>
        </div>
      )
    }
  ```
  2. 子组件向父组件通信
  在用React之前的组件开发模式时，常常需要接收组件运行时的状态，这时我们常用的方有以下两种。
    - 利用回调函数：这是JavaScript灵活方便之处，这样就可以拿到运行时状态。
    - 利用自定义事件机制：这种方法更通用，使用也更广泛。设计组件时，考虑加入事件机制往往可以达到简化组件API的目的。

  在React中，子组件向父组件通信可以使用上面的任意一种方法，但在这种简单的场景下利用自定义事件显然过于复杂，为了达到目的，一般会选择较为简单的方法。

  现在我们在ListItem组件上加上chekbox,并要求勾选动作触发后把选中的项暴露出来：
  ```jsx
    import React, { Component } from 'react'

    class ListItem extends Component {
      static defaultProps = {
        text: '',
        checked: false
      }

      render() {
        const { checked, value, onChange } = this.props
        return (
          <li>
            <input
              type="checkbox"
              checked={checked} 
              value=""
              onChange={onChange}
              >
              <span>{ value }</span>
          </li>
        )
      }
    }

    class List extends Component {
      static defaultProps = {
        list: [],
        handleItemChange: () => {},
      }
      constructor(props) {
        super(props);

        this.state = {
          list: this.props.list.map(entry => ({
            text: entry.text,
            checked: entry.checked
          }))
        }
      }

      onItemChange(entry) {
        const { list } = this.state

        this.setState({
          list: list.map(prevEntry => ({
            text: prevEntry.text,
            checked: prevEntry.text === entry.text ? !prevEntry.checked : prevEntry.checked
          }))
        })

        this.props.handleItemChange(entry)
      }

      render() {
        return (
          <div>
            <ul>
              {
                this.state.list.map((entry, index) => (
                  <ListItem
                    key={`list-${index}`}
                    value={entry.text}
                    checked={entry.checked}
                    onChange={this.onItemChange.bind(this, entry)}
                  />
                ))
              }
            </ul>
          </div>
        )
      }
    }
  ```
  在上述例子中，我们在List组件中构造了handleItemChange方法，这样在使用List组件时，可以在运行时拿到改变的项对应的值，比如：
  ```javascript
    import React, { Component } from 'react';

    class App extends Component {
      constructor(props) {
        super(props);

        this.handleItemChange = this.handleItemChange.bind(this)
      }

      handleItemChange(item) {
        console.log('item', item)
      }

      render() {
        return (
          <List
            list =[{text: 1}, { text: 2}]
            handleItemChange={this.handleItemChange}
          />
        )
      }
    }
  ```
  3. 跨级组件通信
  当需要让子组件跨级访问信息时，我们可以像之前说的方法那样向更高级别的组件层层传递props, 但此时的代码显得不那么优雅，甚至有些冗余。在React中，我们还可以使用context来实现跨级父子组件间的通信：
  ```javascript
    class ListItem extends Component {
      static contextTypes = {
        color: PropTypes.string
      }

      render() {
        const { value } = this.props

        return (
          <li style={{background: this.context.color}}>
            <span>{ value }</span>
          </li>
        )
      }
    }

    class List extends Component {
      static childContextTypes = {
        color: PropTypes.string
      }

      getChildContext() {
        return {
          color: 'red'
        }
      }

      render() {
        const { list } = this.props

        return (
          <div>
            <ListTitle title={title} />
            <ul>
              {
                list.map((entry, index) => (
                  <ListItem key={`list-${index}`} value={entry.text} />
                ))
              }
            </ul>
          </div>
        )
      }
    }
  ```
  可以看到，我们并没有给ListItem传递props,而是在父组件中定义了ChildContext, 这样从这一层开始的子组件都可以拿到定义的context,例如这里的color。
  事实上，context一直存在于React的源码中，但直到react0.14版本才正式记录在官方文档中，不过React官方不建议大量使用context,因为尽管它可以减少逐层传递，但当组件结构复杂的时候，我们并不知道context是从哪里传过来的。context就像一个全局变量一样，而全局变量正是导致应用走向混乱的罪魁祸首之一，给组件带来了外部依赖的副作用。在大部分情况下，我们并不推荐使用context。使用context比较好的场景是真正意义上的全局信息且不会更改，例如界面主题，用户信息等。

  总体的原则是如果我们真的需要它，那么建议写成高阶组件来实现。

  4. 没有嵌套关系的组件通信
  没有嵌套关系的，那么只能通过可以影响全局的一些机制去考虑。刚才见到的自定义事件不失为一种上佳的方法。
  我们在处理事件的过程中需要注意，在componentDidMount事件中，如果组件挂载完成，再订阅事件；当组件卸载的时候，在componentWillUnmount事件中取消事件的订阅。
  我们就以常用的发布/订阅模式来举例，这里借用Node.js Events模块的浏览器版实现。
  对于React使用的场景来说，EventEmitter只需要单例就可以了，因此我们需要单独初始化EventEmitter实例：
  ```javascript
    import { EventEmitter } from 'events'
    export default new EventEmitter()
  ```
  然后把EventEmitter实例输出到各组件中使用：
  ```javascript
    import ReactDOM from 'react-dom'
    import React, { Component, Protypes } from 'react'
    import emitter from './events'

    class ListItem extends Component {
      static defaultProps = {
        checked: false
      }

      constructor(props) {
        super(props)
      }

      render() {
        const { checked, onChange, value } = this.props
        return (
          <li>
            <input type="checkbox" checked={checked} onChange={onChange} />
            <span>{ value }</span>
          </li>
        )
      }
    }

    class List extends Component {
      constructor(props) {
        super(props);

        this.state = {
          list: this.props.list.map(entry => (
            {
              text: entry.text,
              checked: entry.checked || false
            }
          ))
        }
      }

      onItemChange(entry) {
        const { list } = this.state

        this.setState({
          list: list.map(prevEntry => ({
            text: prevEntry.text,
            checked: prevEntry.text === entry.text ? !prevEntry.checked : prevEntry.checked
          }))
        })

        emitter.emit('ItemChange', entry)
      }

      render() {
        return (
          <div>
            <ul>
              {
                this.state.list.map((entry, index) => (
                  <ListItem 
                    key={`list-${index}`}
                    value={entry.text}
                    checked={entry.checked}
                    onChange={this.onItemChange.bind(this, entry)}
                  />
                ))
              }
            </ul>
          </div>
        )
      }
    }

    class App extends Component {
      componentDidMount() {
        this.ItemChange = emitter.on('ItemChange', (data) => {
          console.log(data)
        })
      }

      componentWillUnmount() {
        emitter.removeListener(this.itemChange)
      }

      render() {
        return (
          <List list={[{text: 1}, {text: 2}]} />
        )
      }
    }
  ```
  一般情况下，组件之间的通信尽可能保持简洁。如果说程序中出现多级传递或跨级传递时，那么首先要重新审视一下是否有更合理的方式。Pub/Sub模式实现的过程非常容易理解，即利用全局对象来保存事件，用广播的方式去处理事件。这种常规的设计方法在软件开发中处处可见，但这种模式带来的问题就是逻辑关系混乱。
  跨级通信往往是反模式的典型案例。对于应用开发来说，应该尽量避免仅仅通过例如Pub/Sub实现的设计思路，加入强依赖与约定来进一步梳理流程是更好的方法。

  5. 组件间抽象
  在React组件的构建过程中，常常有这样的场景，有一类功能需要被不同组件公用，此时就涉及抽象的话题。在不同的设计理念下，有许多的抽象方法，而针对React,我们重点讨论两种：mixin和高阶组件。
    - 封装mixin方法
    ```javascript
      const mixin = function(obj, mixins) {
        const newObj = obj
        newObj.prototype = Object.create(obj.prototype)

        for(let prop in mixins) {
          if (mixins.hasOwnProperty(prop)) {
            newObj.prototype[prop] = mixins[prop]
          }
        }

        return newObj
      }

      const BigMixin = {
        fly: () => {
          console.log('I can fly')
        }
      }

      const Big = function() {
        console.log('new big')
      }

      const FlyBig = mixin(Big, BigMixin)
      const flyBig = new FlyBig()
      flyBig.fly()
    ```
    

