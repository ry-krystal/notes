<!--
 * @Description: 组件间抽象
-->
#### 组件间抽象
  1. mixin
  在React组件的构建过程中，常常有这样的场景，有一类功能需要被不同组件公用，此时就涉及抽象的话题。在不同的设计理念下，有许多的抽象方法，而针对React,我们重点讨论两种：mixin和高阶组件。
    - 封装mixin方法
    ```javascript
      const mixin = function(obj, mixins) {
        const newObj = obj
        newObj.prototype = Object.create(obj.prototype)

        for(let prop in mixins) {
          if (mixins.hasOwnProperty(prop)) {
            newObj.prototype[prop] = mixins[prop]
          }
        }

        return newObj
      }

      const BigMixin = {
        fly: () => {
          console.log('I can fly')
        }
      }

      const Big = function() {
        console.log('new big')
      }

      const FlyBig = mixin(Big, BigMixin)
      const flyBig = new FlyBig()
      flyBig.fly()
    ```
  - mixin的问题：
    破坏了原有组件的封装；
    命名冲突
    增加复杂性
  
  2. 高阶组件
  高阶组件：类似于高阶函数，它接受React组件作为输入，输出一个新的React组件，我们用Haskell的函数签名来表达，那就是：
  ```
    hocFactory: W: React.Component => E: React.Component
  ```
  用通俗的语言解释就是，当React组件被包裹时，高阶组件会返回一个增强的React组件。高阶组件让我们的代码更具有复用性、逻辑性与抽象性。它可以对render方法作劫持，也可以控制props与state。

  实现高阶组件的方法如下两种。
  - 属性代理。高阶组件通过被包裹的React组件来操作props。
  - 反向继承。高阶组件继承于被包裹的React组件。

  2.1. 属性代理
  属性代理时常见高阶组件的实现方法。
  ```javascript
    import React, { Component } from 'react'
    const MyContainer = (WrappedComponent) => {
      class extends Component {
        render() {
          return <WrappedComponent { ...this.props } />
        }
      }
    }
  ```
  这样，我们就可以通过高阶组件来传递props，这种方法即为属性代理。
  ```javascript
    import React, { Component } from 'react'
    class MyComponent extends Component {
      // ...
    }
    export default MyContainer(MyComponent)
  ```
  这样组件就可以一层层传地作为参数被调用，原始组件就具备了高阶组件对它的修饰。就这么简单，保持单个组件封装性的同时还保留了易用性。当然，我们也可以用decorator来转换：
  ```javascript
    import React, { Component } from 'React'
    
    @MyContainer
    class MyComponent extends Component {
      render() {}
    }
    export default MyComponent
  ```
  简单地替换成作用在类上的decorator，即接受需要装饰的类为参数，返回一个新的内部类。这与高阶组件的定义完全一致。因此，可以认为作用在类上的decorator语法糖简化了高阶组件的调用。

  当使用属性代理构建高阶组件时，调用顺序不同于mixin。上述执行生命周期的过程类似于堆栈调用：
  ```javascript
    didmount -> HOC didmount -> (HOCs didmount) -> (HOCs will unmount) -> HOC will unmount -> unmount
  ```
  从功能上， 高阶组件一样可以做到像mixin对组件的控制，包括控制props，通过refs使用引用、抽象state和使用其他元素包裹WrappedComponent。
  - 控制props
  我们可以读取、增加、编辑或是移除从WrappedComponent传进来的props,但需要小心删除与编辑重要的props。我们应该尽可能对高阶组件的props作新的命名以防止混淆。
  例如，我们需要增加一个新的prop:
  ```javascript
    import React, { Component } from 'react'

    const MyContainer = (WrappedComponent) => {
      class extends Component {
        render() {
          const newProps = {
            text: newText
          }
          return <WrappedComponent {...this.props} {...newProps} />
        }
      }
    }
  ```
  - 通过refs使用引用
  在高阶组件中，我们可以接受refs使用WrappedComponent的引用。例如：
  ```javascript
    import React, { Component } from 'react'
    const MyContainer = (WrappedComponent) => 
      class extends Component {
        proc(WrappedComponentInstance) {
          WrappedComponentInstance.method()
        }

        render() {
          const props = Object.assign({}, this.props, {
              ref: this.proc.bind(this)
            })
          return <WrappedComponent {...props} />
        }
      }
  ```
  - 抽象state
  高阶组件可以将原组件抽象为展示型组件，分离内部状态。
  ```javascript
    import React, { Component } from 'react'

    const MyContainer = (WrappedComponent) => 
      class extends Component {
        constructor(props) {
          super(props)
          this.state = {
            name: ''
          }

          this.onNameChange = this.onNameChange.bind(this)
        }

        onNameChange(event) {
          this.setState({
            name: event.target.value
          })
        }

        render() {
          const newProps = {
            name: {
              value: this.state.name,
              onChange: this.onNameChange
            }
          }
          return <WrappedComponent {...this.props } { ...newProps }>
        }
      }
  ```
  在这个例子中，我们把input组件中对name prop的onChagne方法提取到高阶组件中，这样就有效地抽象了同样的state操作。可以这么来使用它：
  ```javascript
    import React, { Component } from 'react'

    @MyContainer
    class MyComponent extends Component {
      render() {
        return <input name="name" {...this.props.name} /> 
      }
    }
  ```
  通过这样的封装，我们就得到了一个被控制的input组件。

  - 使用其他元素包裹WrappedComponent
  此外，我们还可以使用其他元素来包裹WrappedComponent，这既可以是为了加样式，也可以是为了布局。比如，我们增加一层来定义样式：
  ```javascript
    import React, { Component } from 'react'
    
    const MyContainer = (WrappedComponent) =>
      class extends Component {
        render() {
          return {
            <div style={{display: 'block'}}>
              <WrappedComponent {...this.props} />
            </div>
          }
        }
      }
  ```
  2.2 反向继承
  另一种构建高阶组件的方法称为反向继承，从字面意思上看，它一定与继承特性相关。
  ```javascript
    const MyContainer = (WrappedComponent) => 
      class extends WrappedComponent {
        render() {
          return super.render()
        }
      }
  ```
  高阶组件返回的组件继承于WrappedComponent。因为被动地继承了WrappedComponent，所有的调用都会反向，这也是这种方法的由来。

  在反向继承方法中，高阶组件可以使用WrappedComponent引用，这意味着它可以使用WrappedComponent的state、props、生命周期和render方法。但它不能保证完整的子组件树被解析。

  它有两个比较大的特点：
  - 渲染劫持
  渲染劫持指的就是高阶组件可以控制WrappedComponent的渲染过程，并渲染各种各样的结果。我们可以在这个过程中在任何React元素输出的结果中读取、增加、修改、删除props，或读取或修改React元素树，或条件显示元素树，又或是用样式控制包裹元素树。

  正如之前说到的，反向继承不能保证完整的子组件树被解析，这意味着将限制渲染劫持功能。渲染劫持的经验法则是我们可以操控WrappedComponent的元素树，并输出正确地结果。但 __如果元素树种包括了函数类型的React组件，就不能操作组件的子组件。__
  第一个示例：
  ```javascript
    const MyContainer = (WrappedComponent) => 
      class extends WrappedComponent {
        render() {
          if (this.props.loggedIn) {
            return super.render()
          } else {
            return null
          }
        }
      }
  ```
  第二个示例是我们可以对render的输出结果进行修改：
  ```javascript
  const MyContainer = (WrappedComponent) => 
    class extends WrappedComponent {
      render() {
        const elementsTree = super.render()
        let newProps = {}
        if (elementsTree?.type === 'input') {
          newProps = {
            value: 'may the force be with you'
          }
        }
        const props = Object.assign({}, elementsTree.props, newProps)
        const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)
        return newElementsTree
      }
    }
  ```
  在这个例子中，WrappedComponent的渲染结果中，顶层的input组件的value被改写，因此，我们可以做各种各样的事，甚至可以反转元素树，或是改变元素树种的props。这也是Radium库构造的方法。

  - 控制state
  高阶组件可以读取、修改或删除WrappedComponent实例中的state, 如果需要的话，也可以增加state。但这样做，可能会让WrappedComponent组件内部状态变得一团糟。大部分的高阶组件都应该限制读取或新增state，尤其是后者，可以通过重新命名state,以防止混淆。
  ```javascript
    const MyContainer = (WrappedComponent) => 
      class extends WrappedComponent {
        render() {
          return (
            <div>
              <h2>HOC Debugger Component</h2>
              <p>Props</p> <pre>{JSON.stringify(this.props, null, 2)}</pre> 
              <p>State</p><pre>{JSON.stringify(this.state, null, 2)}</pre>
              { super.render() }
            </div>
          )
        }
      }
  ```
  在这个例子中，显示了WrappedComponent的props和state,以方便我们在程序中去调试它们。

  2.3 组件命名
  当包裹一个高阶组件时，我们失去了原始WrappedComponent的displayName,而组件名字是方便我们开发与调试的重要属性。
  那可以怎么做呢? 这里可以参考react-redux库中的实现：
  ```javascript
    HOC.displayNmae = `HOC(${getDisplayName(WrappedComponent)})`

    // 或者

    class HOC extends ... {
      static displayName = `HOC(${getDisplayName(WrappedComponent)})`
    }
    function getDisplayName(WrappedComponent) {
      return WrappedComponent.displayName ||
        WrappedComponent.name ||
        'Component'
    }
  ```
  2.4 组件参数
  有时，我们调用高阶组件时需要传入一些参数，这可以用非常简单的方式来实现：
  ```javascript
    import React, { Component } from 'react'
    function HOCFactoryFactory(...params) {
      // 可以做一些改变params的事
      return function HOCFactory(WrappedComponent) {
        return class HOC extends Component {
          render() {
            return <WrappedComponent {...this.props} />
          }
        }
      }
    }
    // 使用的时候，可以这么写:
    HOCFactoryFactory(params)(WrappedComponent)
    //  或者
    @HOCFactoryFactory(params)
    class WrappedComponent extends React.Component{}
  ```