<!--
 * @Description: 
-->
<!--
 * @Description: 事件系统
-->
#### 事件系统
  1. 合成事件的实现机制
  在React底层，主要对合成事件做了两件事：事件委派和自动绑定。
  1.事件委派
  __React并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。__ 当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样就简化了事件处理和回收机制，效率有很大提升。
  <br />
  2. 自动绑定
  在React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。而且React还会对这种引用进行缓存，以达到CPU和内存的最优化。__在使用ES6 classes或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现this的绑定。__
  <br />
  有以下几种绑定方法：
      - bind方法。这个方法可以帮助我们绑定事件处理器内的this,并可以向事件处理器中传递参数，比如：

      ```javascript
        import React, { Component } from 'react';

        class App extends Component {
          handleClick(e, arg) {
            console.log(e, arg)
          }

          render() {
            // 通过bind方法实现，可以传递参数
            return (
              <button onClick={this.handleClick.bind(this, 'test')}>
                Test
              </button>
            )
          }
        }
      ```
      如果方法只绑定，不传参，那stage0草案中提供了一个便捷的方案--双冒号语法，其作用于this.handleClick.bind(this)一致，并且Babel已经实现了该提案，例如：
      ```javascript
        import React, { Component } from 'react'
        class App extends Component {
          handleClick(e) {
            console.log(e)
          }

          render() {
            return <button onClick={::this.handleClick}>Test</button>
          }
        } 
      ```
      - 构造器内声明
      在组件的构造器内完成this的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听器时去执行绑定操作：
      ```javascript
        import React, { Component } from 'react'
        class App extends Component {
          constructor(props) {
            super(props)
            this.handleClick = this.handleClick.bind(this)
          }
          handleClick(e) {
            console.log(e)
          }

          render() {
            return <button onClick={this.handleClick}>Test</button>
          }
        }
      ```
      - 箭头函数
      箭头函数不仅是函数的“语法糖”，它还自动绑定了定义此函数作用域的this,因此我们不再需要对它使用bind方法。
      ```javascript
        import React, { Component } from 'react'
        class App extends Component {
          const handleClick = (e) => {
            console.log(e)
          }

          render() {
            return <button onClick={this.handleClick}>Test</button>
          }
        }
      ```
      或
      ```javascript
       import React, { Component } from 'react'
        class App extends Component {
          handleClick(e) {
            console.log(e)
          }

          render() {
            return <button onClick={() => handleClick()}>Test</button>
          }
        }
      ```
      <br />
  3. React中使用原生事件
  React提供了很好的合成事件系统，但这并不意味着再React架构下无法使用原生事件，React提供了完备的生命周期方法，其中componentDidMount会在组件已经完成安装并且在浏览器中存在真实DOM后调用，此时我们就可以完成原生事件的绑定。
  ```javascript
    import React, { Component } from 'react'
    class NativeEventDemo extends Component {
      handleClick(e) {
        console.log(e)
      }

      componentDidMount() {
        this.refs.button.addEventListener('click', this.handleClick)
      }

      componentWillUnmount() {
        this.refs.button.removeEventListener('click', this.handleClick)
      }

      render() {
        return <button ref="button">Test</button>
      }
    } 
  ```
  值得注意的是，在React中使用DOM原生事件时，一定要在组件卸载时手动移动，否则很可能出现内存泄露问题。而使用合成事件系统时则不需要，因为React内部已经帮你妥善处理了。