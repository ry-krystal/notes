<!--
 * @Description: 
-->
<!--
 * @Description: 事件系统
-->
#### 事件系统
  1. 合成事件的实现机制
  在React底层，主要对合成事件做了两件事：事件委派和自动绑定。
  1.事件委派
  __React并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。__ 当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样就简化了事件处理和回收机制，效率有很大提升。
  <br />

  2. 自动绑定
  在React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。而且React还会对这种引用进行缓存，以达到CPU和内存的最优化。__在使用ES6 classes或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现this的绑定。__
  <br />
  有以下几种绑定方法：
  - bind方法。这个方法可以帮助我们绑定事件处理器内的this,并可以向事件处理器中传递参数，比如：

  ```javascript
    import React, { Component } from 'react';

    class App extends Component {
      handleClick(e, arg) {
        console.log(e, arg)
      }

      render() {
        // 通过bind方法实现，可以传递参数
        return (
          <button onClick={this.handleClick.bind(this, 'test')}>
            Test
          </button>
        )
      }
    }
  ```
  如果方法只绑定，不传参，那stage0草案中提供了一个便捷的方案--双冒号语法，其作用于this.handleClick.bind(this)一致，并且Babel已经实现了该提案，例如：

  ```javascript
    import React, { Component } from 'react'
    class App extends Component {
      handleClick(e) {
        console.log(e)
      }

      render() {
        return <button onClick={::this.handleClick}>Test</button>
      }
    } 
  ```
  - 构造器内声明
  在组件的构造器内完成this的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听器时去执行绑定操作：
  ```javascript
    import React, { Component } from 'react'
    class App extends Component {
      constructor(props) {
        super(props)
        this.handleClick = this.handleClick.bind(this)
      }
      handleClick(e) {
        console.log(e)
      }

      render() {
        return <button onClick={this.handleClick}>Test</button>
      }
    }
  ```
  - 箭头函数
  箭头函数不仅是函数的“语法糖”，它还自动绑定了定义此函数作用域的this,因此我们不再需要对它使用bind方法。
  ```javascript
    import React, { Component } from 'react'
    class App extends Component {
      const handleClick = (e) => {
        console.log(e)
      }

      render() {
        return <button onClick={this.handleClick}>Test</button>
      }
    }
  ```
  或
  ```javascript
    import React, { Component } from 'react'
    class App extends Component {
      handleClick(e) {
        console.log(e)
      }

      render() {
        return <button onClick={() => handleClick()}>Test</button>
      }
    }
  ```
  <br />

  3. React中使用原生事件
  React提供了很好的合成事件系统，但这并不意味着再React架构下无法使用原生事件，React提供了完备的生命周期方法，其中componentDidMount会在组件已经完成安装并且在浏览器中存在真实DOM后调用，此时我们就可以完成原生事件的绑定。
  
  ```javascript
    import React, { Component } from 'react'
    class NativeEventDemo extends Component {
      handleClick(e) {
        console.log(e)
      }

      componentDidMount() {
        this.refs.button.addEventListener('click', this.handleClick)
      }

      componentWillUnmount() {
        this.refs.button.removeEventListener('click', this.handleClick)
      }

      render() {
        return <button ref="button">Test</button>
      }
    } 
  ```
  值得注意的是，在React中使用DOM原生事件时，一定要在组件卸载时手动移动，否则很可能出现内存泄露问题。而使用合成事件系统时则不需要，因为React内部已经帮你妥善处理了。
  <br />

4. 合成事件与原生事件混用
既然React合成事件系统有这么多好处，那是不是React中就不需要原生事件了呢？当然不是，因为还有很多应用场景只能借助原生事件的帮助才能完成。比如，在Web页面中添加一个使用移动设备扫描二维码的功能，在点击按钮时显示二维码，点击非二维码区域时将其隐藏起来，示例：
```javascript
  import React, { Component } from 'react'

  class QrCode extends Component {
    constructor(props) {
      super(props);
      this.handleClick = this.handleClick.bind(this)
      this.handleClickQr = this.handleClickQr.bind(this)
      
      this.state = {
        active: false
      }
    }

    handleClick(e) {
      e.preventDefault()
      this.setState({
        active: !this.state.active
      })
    }

    handleClickQr(e) {
      e.preventDefault()
    }

    handleActive(e) {
      this.setState({
        active: false
      })
    }

    componentDidMount() {
      document.body.addEventListener('click', this.handleActive)
    }

    componentWillUnmount() {
      document.body.removeEventListener('click', this.handleActive)
    }

    render() {
      const styleObj = {
        display: this.state.active ? 'block' ： ‘none’
      }
      return (
        <div className="qr-wrapper">
          <button className="qr" onClick={this.handleClick}>二维码</button>
          <div
            className="code"
            style={styleObj}
            onClick={this.handleClickQr}
          >
            <img src="qr.jpg" alt="qr" />
          </div>
        </div>
      )
    }
  }
```
点击按钮可以切换二维码的显示与隐藏，而在按钮之外的区域同样可以达到隐藏的效果。然而，我们无法在组件中将事件绑定到body上，因为body在组件范围之外，只能用原生绑定事件来实现。
逻辑似乎很简单，但React所表现的似乎与你所想的并不一致，实际效果是在你点击二维码区域时二维码依然会隐藏起来。原因很简单，__就是React合成事件系统的委托机制，在合成事件内部仅仅对最外层的容器进行了绑定，并且依赖事件的冒泡机制完成了委派。__
也就是说，事件并没有直接绑定到div.code元素上
 - 不要将合成事件与原生事件混用
 ```javascript
  handleClick(e) {
    this.setState({
      active: false
    })
  }

  handleClick(e) {
    e.preventDefault()
  }

  componentDidMount() {
    document.body.addEventListener('click', this.handleClick)
    document.querySelector('.code').addEventListener('click', this.handleClickQr)
  }

  componentWillUnmount() {
    document.body.removeEventListener('click', this.handleClick)
    document.querySelector('.code').removeEventListener('click', this.handleClickQr)
  }
 ```
 - 通过e.target判断来避免。
 ```javascript
  componentDidMount() {
    document.body.addEventListener('click', e => {
      if (e?.target.matches('div.code')) return
      this.setState({
        active: false
      })
    })
  }
 ```
 所以，尽量避免在React中混用合成事件和原生DOM事件。另外，用reactEvent.nativeEvent.stopPropagation()来阻止冒泡是不行的。__阻止React事件冒泡的行为只能用于React合成事件系统中，且没有办法阻止原生事件的冒泡。反之，在原生事件中的阻止冒泡行为，却可以阻止React合成事件的传播。__
 实际上，__React的合成事件系统只是原生DOM事件系统的一个子集。__ 它仅仅实现了DOM Level3的事件接口，并且统一了浏览器的兼容问题。有些事件React并没有实现，或者受某些限制没办法去实现，比如window的resize事件。
 __对于无法使用React合成事件的场景，我们还需要使用原生事件来完成。__