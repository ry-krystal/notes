<!--
 * @Author: renyong
 * @Date: 2022-08-30 23:45:57
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2022-09-05 00:00:47
 * @Description: 
-->
#### React 数据流
在React中，数据是自顶向下单向流动的，即从父组件到子组件。这条原则让组件之间的关系变得简单且可预测。

__如果顶层组件初始化props，那么React会向下遍历整棵组件树，重新尝试渲染所有相关的子组件，而state只关心每个组件自己内部的状态，这些状态只能在组件内改变。__

__1.1  state__

``` javascript
  import React, { Component } from 'react';

  class Counter extends Component {
    constructor(props) {
      super(props);
      this.handleClick = this.handleClick.bind(this);
      this.state = {
        count: 0
      }
    }

    handleClick(e) {
      e.preventDefault();

      this.setState({
        count: this.state.count + 1
      })
    }

    render() {
      return(
        <div>
          <p>{ this.state.count }</p>
          <a href="#" onClick={ this.handleClick }></a>
        </div>
      )
    }
  }
```
__1.2 props__

React的单向数据流，主要的流动管道就是props。props本身是不可变的，当我们试图改变props的值时，React会报出类型错误的警告，组件的props一定来自于默认属性或父组件传递而来。如果要渲染一个对props加工后的值，最简单的方法就是使用局部变量或直接在JSX中计算结果。

__对于React组件来说，我们考虑设计组件一定要满足一大原则---直观。把基本设置与数据一起定义成一个数组或对象是初学者最容易犯的一个错误，如果组件能分解，那我们一定要分解，并使用子组件的方式来处理。__

  - 1.2.1 子组件prop
  在React中有一个重要且内置的prop—children,它代表组件的子组件集合。__children可以根据传入子组件的数量来决定是否是数组类型。__
  ```html
    <Tabs classPrefix={'tabs'} defaultActiveIndex={0}>
      <TabPane key={0} tab={'Tab 1'}>第一个Tab里的内容</TabPane>
      <TabPane key={1} tab={'Tab 2'}>第二个Tab里的内容</TabPane>
      <TabPane key={2} tab={'Tab 3'}>第三个Tab里的内容</TabPane>
    </Tabs>
  ```
  $\Downarrow$ 翻译
  ```javascript
    <Tabs classPrefix={'tabs'} defaultActiveIndex={0} className="tabs-bar">
      children={
        [
          <TabPane key={0} tab={'Tab 1'}>第一个Tab里的内容</TabPane>
          <TabPane key={1} tab={'Tab 2'}>第二个Tab里的内容</TabPane>
          <TabPane key={2} tab={'Tab 3'}>第三个Tab里的内容</TabPane>
        ]
      }
    </Tabs>
  ```
  实现的基本思路就以TabContent组件渲染TabPane子组件集合为例来讲，其中渲染TabPane组件的方法如下：
  ```javascript
    getTabPanes() {
      const {
        classPrefix,
        activeIndex,
        panels,
        isActive
      } = this.props;

      return React.children.map(panels, (child) => {
        if (!child) return

        const order = parseInt(child.props.order, 10);
        const isActive = activeIndex === order;

        return React.cloneElement(child, {
          classPrefix,
          isActive,
          children: child.props.children,
          key: `tabpane-${order}`
        });
      });
    }
  ```
  - 1.2.2 组件props
  对于子组件而言，我们不仅可以直接使用this.props.children定义，也可以将子组件以props的形式传递。一般我们会用这种方法来让开发者定义组件的某一个prop，让其具备多种类型，来做到简单配置和自定义配置组合在一起的效果。
  ```javascript
    <Tabs classPrefix={'tabs'} defaultActiveIndex={0}   className="tabs-bar">
      <TabPane 
        order="0"
        tab={<span>
          <i className="fa fa-home"></i>
          &nbsp;
          Home
        </span>}
      >
      </TabPane>
    </Tabs>
  ```
  下面是写在TabNav组件中简化的渲染子组件集合的方法：
  ```javascript
    getTabs() {
      const {
        classPrefix,
        activeIndex,
        panels
      } = this.props
      return React.Children.map(panels, (child) => {
        if (!child) return
        
        const order = parseInt(child.props.order, 10)

        let classes = classNames({
          [`${classPrefix}-tab`]: true,
          [`${classPrefix}-active`]: activeIndex === order,
          [`${classPrefix}-disabled`]: child.props.disabled,
        })

        return (
          <li>{ child.props.tab }</li>
        )
      })
    }
  ```
  
