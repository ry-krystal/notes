<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 
      搜索插入位置

      给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
      请必须使用时间复杂度为 O(log n) 的算法。

      示例 1:
      输入: nums = [1,3,5,6], target = 5
      输出: 2
    
      示例 2:
      输入: nums = [1,3,5,6], target = 2
      输出: 1
      示例 3:

      输入: nums = [1,3,5,6], target = 7
      输出: 4

      提示:

      1 <= nums.length <= 104
      -104 <= nums[i] <= 104
      nums 为 无重复元素 的 升序 排列数组
      -104 <= target <= 104
    */

      /**
       * @description: 搜索插入位置
       * @param {*} nums
       * @param {*} target
       * @return {*}
       */
      const searchInsert = (nums, target) => {
        // 采用二分法

        // 闭区间 [left, right]
        let left = 0;
        let right = nums.length - 1;
        while (left <= right) {
          let mid = Math.floor((left + right) / 2);
          nums[mid] < target ? (left = mid + 1) : (right = mid - 1);
        }
        return left; // 或者right + 1

        // 左闭右开 [left, right)
        // let left = 0;
        // let right = nums.length;
        // while(left < right) {
        //     let mid = Math.floor((left + right) / 2)
        //     nums[mid] < target ? (left = mid + 1) : (right = mid)
        // }
        // return left // 或者right

        // 开区间 (left, right)
        // let left = -1
        // let right = nums.length
        // while(left + 1 < right) {
        //     let mid = Math.floor((left + right) / 2)
        //     nums[mid] < target ? (left = mid) : (right = mid)
        // }
        // return right // 或者left + 1
      };
    </script>
  </body>
</html>
